var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"buildover_fullstatemachine","ref":false,"files":[{"name":"ert_main.cpp","type":"source","group":"main","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Main file","code":"#include <stdio.h>\r\n#include <stdlib.h>\r\n#include \"buildover_fullstatemachine.h\"\r\n#include \"buildover_fullstatemachine_private.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"limits.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"MW_PX4_TaskControl.h\"\r\n#include \"nuttxinitialize.h\"\r\n#define UNUSED(x)                      x = x\r\n#define NAMELEN                        16\r\n\r\nvoid exitFcn(int sig);\r\nvoid *terminateTask(void *arg);\r\nvoid *baseRateTask(void *arg);\r\nvoid *subrateTask(void *arg);\r\nvolatile boolean_T stopRequested = false;\r\nvolatile boolean_T runModel = true;\r\npx4_sem_t stopSem;\r\npx4_sem_t baserateTaskSem;\r\npthread_t schedulerThread;\r\npthread_t baseRateThread;\r\nvoid *threadJoinStatus;\r\nint terminatingmodel = 0;\r\nvoid *baseRateTask(void *arg)\r\n{\r\n  runModel = (rtmGetErrorStatus(buildover_fullstatemachine_M) == (NULL));\r\n  while (runModel) {\r\n    px4_sem_wait(&baserateTaskSem);\r\n    buildover_fullstatemachine_step();\r\n    stopRequested = !((rtmGetErrorStatus(buildover_fullstatemachine_M) == (NULL)));\r\n  }\r\n\r\n  runModel = 0;\r\n  terminateTask(arg);\r\n  pthread_exit((void *)0);\r\n  return NULL;\r\n}\r\n\r\nvoid exitFcn(int sig)\r\n{\r\n  UNUSED(sig);\r\n  rtmSetErrorStatus(buildover_fullstatemachine_M, \"stopping the model\");\r\n  runModel = 0;\r\n}\r\n\r\nvoid *terminateTask(void *arg)\r\n{\r\n  UNUSED(arg);\r\n  terminatingmodel = 1;\r\n\r\n  {\r\n    runModel = 0;\r\n  }\r\n\r\n  MW_PX4_Terminate();\r\n  buildover_fullstatemachine_terminate();\r\n  px4_sem_post(&stopSem);\r\n  return NULL;\r\n}\r\n\r\nint px4_simulink_app_task_main (int argc, char *argv[])\r\n{\r\n  px4_simulink_app_control_MAVLink();\r\n  rtmSetErrorStatus(buildover_fullstatemachine_M, 0);\r\n  buildover_fullstatemachine_initialize();\r\n  nuttxRTOSInit(0.001, 0);\r\n  px4_sem_wait(&stopSem);\r\n\r\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\r\n\r\n  {\r\n    int i;\r\n    for (i=0; i < MW_NUMBER_TIMER_DRIVEN_TASKS; i++) {\r\n      CHECK_STATUS(px4_sem_destroy(&timerTaskSem[i]), 0, \"px4_sem_destroy\");\r\n    }\r\n  }\r\n\r\n#endif\r\n\r\n  return 0;\r\n}\r\n"},{"name":"buildover_fullstatemachine.cpp","type":"source","group":"model","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Model files","code":"#include \"buildover_fullstatemachine.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"buildover_fullstatemachine_types.h\"\r\n#include <math.h>\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\n#include \"buildover_fullstatemachine_private.h\"\r\n#include <uORB/topics/actuator_outputs_commanded.h>\r\n#include \"rt_defines.h\"\r\n#include \"zero_crossing_types.h\"\r\n\r\nconst uint8_T buildover_IN_Rotor_DEACCEL_prep = 7U;\r\nconst uint8_T buildover_ful_IN_FF_Preparation = 1U;\r\nconst uint8_T buildover_ful_IN_Forward_Flight = 2U;\r\nconst uint8_T buildover_full_IN_Rotor_DEACCEL = 6U;\r\nconst uint8_T buildover_full_IN_Rotor_Spin_Up = 8U;\r\nconst uint8_T buildover_fulls_IN_off_disarmed = 11U;\r\nconst uint8_T buildover_fullst_IN_Rotor_ACCEL = 5U;\r\nconst uint8_T buildover_fullsta_IN_Quad_Hover = 4U;\r\nconst uint8_T buildover_fullstat_IN_off_armed = 10U;\r\nconst uint8_T buildover_fullstatemach_IN_Kill = 3U;\r\nconst uint8_T buildover_fullstatemach_IN_VTOL = 9U;\r\nconst real_T buildover_fullstatemachi_period = 0.001;\r\nB_buildover_fullstatemachine_T buildover_fullstatemachine_B;\r\nDW_buildover_fullstatemachine_T buildover_fullstatemachine_DW;\r\nPrevZCX_buildover_fullstatema_T buildover_fullstatemach_PrevZCX;\r\nRT_MODEL_buildover_fullstatem_T buildover_fullstatemachine_M_ =\r\n  RT_MODEL_buildover_fullstatem_T();\r\nRT_MODEL_buildover_fullstatem_T *const buildover_fullstatemachine_M =\r\n  &buildover_fullstatemachine_M_;\r\nstatic void buildover_fullsta_Rotor_DEACCEL(boolean_T *arm_output, real_T\r\n  *Tune_ID, real_T *slider_position, const uint16_T *uDLookupTable6, const\r\n  real_T *Diff, real_T *w_ff_gain);\r\nstatic void buildover_fullstatema_off_armed(boolean_T *arm_output, real_T\r\n  *Tune_ID, real_T *slider_position, const uint16_T *uDLookupTable6, real_T\r\n  *w_ff_gain, const real_T *CastToDouble);\r\nstatic real_T buildover_fullstatemachine_norm(const real_T x[4]);\r\nstatic void buildover_fullstat_expand_atan2(const real_T a_data[], const int32_T\r\n  *a_size, const real_T b_data[], const int32_T *b_size, real_T c_data[],\r\n  int32_T *c_size);\r\nstatic void buildover_full_binary_expand_op(real_T in1[3], const int32_T\r\n  in2_data[], const real_T in3_data[], const int32_T *in3_size, const real_T\r\n  in4_data[], const int32_T *in4_size);\r\nstatic void buildover_full_SystemCore_setup(px4_internal_block_PWM_buildo_T *obj,\r\n  boolean_T varargin_1, boolean_T varargin_2);\r\nreal_T look1_binlxpw(real_T u0, const real_T bp0[], const real_T table[],\r\n                     uint32_T maxIndex)\r\n{\r\n  real_T frac;\r\n  real_T yL_0d0;\r\n  uint32_T iLeft;\r\n  if (u0 <= bp0[0U]) {\r\n    iLeft = 0U;\r\n    frac = (u0 - bp0[0U]) / (bp0[1U] - bp0[0U]);\r\n  } else if (u0 < bp0[maxIndex]) {\r\n    uint32_T bpIdx;\r\n    uint32_T iRght;\r\n    bpIdx = maxIndex >> 1U;\r\n    iLeft = 0U;\r\n    iRght = maxIndex;\r\n    while (iRght - iLeft > 1U) {\r\n      if (u0 < bp0[bpIdx]) {\r\n        iRght = bpIdx;\r\n      } else {\r\n        iLeft = bpIdx;\r\n      }\r\n\r\n      bpIdx = (iRght + iLeft) >> 1U;\r\n    }\r\n\r\n    frac = (u0 - bp0[iLeft]) / (bp0[iLeft + 1U] - bp0[iLeft]);\r\n  } else {\r\n    iLeft = maxIndex - 1U;\r\n    frac = (u0 - bp0[maxIndex - 1U]) / (bp0[maxIndex] - bp0[maxIndex - 1U]);\r\n  }\r\n\r\n  yL_0d0 = table[iLeft];\r\n  return (table[iLeft + 1U] - yL_0d0) * frac + yL_0d0;\r\n}\r\n\r\nuint32_T plook_u32u16_bincka(uint16_T u, const uint16_T bp[], uint32_T maxIndex)\r\n{\r\n  uint32_T bpIndex;\r\n  if (u <= bp[0U]) {\r\n    bpIndex = 0U;\r\n  } else if (u < bp[maxIndex]) {\r\n    bpIndex = binsearch_u32u16(u, bp, maxIndex >> 1U, maxIndex);\r\n  } else {\r\n    bpIndex = maxIndex;\r\n  }\r\n\r\n  return bpIndex;\r\n}\r\n\r\nuint32_T binsearch_u32u16(uint16_T u, const uint16_T bp[], uint32_T startIndex,\r\n  uint32_T maxIndex)\r\n{\r\n  uint32_T bpIdx;\r\n  uint32_T bpIndex;\r\n  uint32_T iRght;\r\n  bpIdx = startIndex;\r\n  bpIndex = 0U;\r\n  iRght = maxIndex;\r\n  while (iRght - bpIndex > 1U) {\r\n    if (u < bp[bpIdx]) {\r\n      iRght = bpIdx;\r\n    } else {\r\n      bpIndex = bpIdx;\r\n    }\r\n\r\n    bpIdx = (iRght + bpIndex) >> 1U;\r\n  }\r\n\r\n  return bpIndex;\r\n}\r\n\r\nstatic void buildover_fullsta_Rotor_DEACCEL(boolean_T *arm_output, real_T\r\n  *Tune_ID, real_T *slider_position, const uint16_T *uDLookupTable6, const\r\n  real_T *Diff, real_T *w_ff_gain)\r\n{\r\n  if (buildover_fullstatemachine_B.CastToDouble16 == 1.0) {\r\n    buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n      buildover_fullstatemach_IN_Kill;\r\n    buildover_fullstatemachine_B.lcb_speed =\r\n      buildover_fullstatemachine_P.Constant_Value_fc;\r\n    buildover_fullstatemachine_B.leftcb_angle =\r\n      buildover_fullstatemachine_P.Constant_Value_fc;\r\n    buildover_fullstatemachine_B.mainrotor_control =\r\n      buildover_fullstatemachine_P.Constant_Value_fc;\r\n    buildover_fullstatemachine_B.rcb_speed =\r\n      buildover_fullstatemachine_P.Constant_Value_fc;\r\n    buildover_fullstatemachine_B.rightcb_angle =\r\n      buildover_fullstatemachine_P.Constant_Value_fc;\r\n    *slider_position = buildover_fullstatemachine_P.Constant_Value_fc;\r\n    buildover_fullstatemachine_B.tau_ff_gain =\r\n      buildover_fullstatemachine_P.Constant_Value_fc;\r\n    *w_ff_gain = buildover_fullstatemachine_P.Constant_Value_fc;\r\n    *Tune_ID = buildover_fullstatemachine_P.Constant13_Value;\r\n    *arm_output = buildover_fullstatemachine_P.Constant1_Value_a;\r\n  } else if ((*uDLookupTable6 == 7) && (*Diff == 0.0)) {\r\n    buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n      buildover_fulls_IN_off_disarmed;\r\n    *w_ff_gain = buildover_fullstatemachine_P.Constant12_Value_d;\r\n    buildover_fullstatemachine_B.tau_ff_gain =\r\n      buildover_fullstatemachine_P.Constant1_Value_o;\r\n    *Tune_ID = buildover_fullstatemachine_P.Constant11_Value_c;\r\n    buildover_fullstatemachine_B.lcb_speed =\r\n      buildover_fullstatemachine_P.Constant2_Value_o4;\r\n    buildover_fullstatemachine_B.rcb_speed =\r\n      buildover_fullstatemachine_P.Constant2_Value_o4;\r\n    buildover_fullstatemachine_B.mainrotor_control =\r\n      buildover_fullstatemachine_P.Constant3_Value_l;\r\n    buildover_fullstatemachine_B.leftcb_angle =\r\n      buildover_fullstatemachine_P.Constant4_Value_i;\r\n    buildover_fullstatemachine_B.rightcb_angle =\r\n      buildover_fullstatemachine_P.Constant4_Value_i;\r\n    *slider_position = buildover_fullstatemachine_P.Constant6_Value_b;\r\n    *arm_output = buildover_fullstatemachine_P.Constant13_Value_f;\r\n  } else if ((*uDLookupTable6 == 2) && (*Diff == 0.0)) {\r\n    buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n      buildover_fullsta_IN_Quad_Hover;\r\n    buildover_fullstatemachine_B.lcb_speed =\r\n      buildover_fullstatemachine_P.Constant3_Value_j;\r\n    buildover_fullstatemachine_B.mainrotor_control =\r\n      buildover_fullstatemachine_P.Constant4_Value_g;\r\n    buildover_fullstatemachine_B.rcb_speed =\r\n      buildover_fullstatemachine_P.Constant5_Value_p;\r\n    buildover_fullstatemachine_B.rightcb_angle =\r\n      buildover_fullstatemachine_P.Constant1_Value_dz;\r\n    buildover_fullstatemachine_B.leftcb_angle =\r\n      buildover_fullstatemachine_P.Constant14_Value;\r\n    *slider_position = buildover_fullstatemachine_P.Constant7_Value_e;\r\n    *w_ff_gain = buildover_fullstatemachine_P.Constant2_Value_b;\r\n    buildover_fullstatemachine_B.tau_ff_gain =\r\n      buildover_fullstatemachine_P.Constant6_Value_p;\r\n    *Tune_ID = buildover_fullstatemachine_P.Constant8_Value_c;\r\n    *arm_output = buildover_fullstatemachine_P.Constant13_Value_p;\r\n  } else if ((*uDLookupTable6 == 6) && (*Diff == 0.0)) {\r\n    buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n      buildover_ful_IN_FF_Preparation;\r\n    buildover_fullstatemachine_B.lcb_speed =\r\n      buildover_fullstatemachine_P.Constant_Value_e;\r\n    buildover_fullstatemachine_B.mainrotor_control =\r\n      buildover_fullstatemachine_P.Constant4_Value;\r\n    buildover_fullstatemachine_B.rcb_speed =\r\n      buildover_fullstatemachine_P.Constant3_Value;\r\n    buildover_fullstatemachine_B.rightcb_angle =\r\n      buildover_fullstatemachine_P.Constant5_Value;\r\n    buildover_fullstatemachine_B.leftcb_angle =\r\n      buildover_fullstatemachine_P.Constant1_Value;\r\n    *slider_position = buildover_fullstatemachine_P.Constant9_Value;\r\n    *w_ff_gain = buildover_fullstatemachine_P.Constant6_Value;\r\n    buildover_fullstatemachine_B.tau_ff_gain =\r\n      buildover_fullstatemachine_P.Constant7_Value;\r\n    *Tune_ID = buildover_fullstatemachine_P.Constant8_Value;\r\n    *arm_output = buildover_fullstatemachine_P.Constant13_Value_j;\r\n  } else {\r\n    buildover_fullstatemachine_B.lcb_speed =\r\n      buildover_fullstatemachine_P.Constant6_Value_c;\r\n    buildover_fullstatemachine_B.mainrotor_control =\r\n      buildover_fullstatemachine_P.Constant5_Value_l;\r\n    buildover_fullstatemachine_B.rcb_speed =\r\n      buildover_fullstatemachine_P.Constant4_Value_o;\r\n    buildover_fullstatemachine_B.rightcb_angle =\r\n      buildover_fullstatemachine_P.Constant3_Value_e;\r\n    buildover_fullstatemachine_B.leftcb_angle =\r\n      buildover_fullstatemachine_P.Constant14_Value_i;\r\n    *slider_position = buildover_fullstatemachine_P.Constant_Value_ml;\r\n    *w_ff_gain = buildover_fullstatemachine_P.Constant1_Value_n;\r\n    buildover_fullstatemachine_B.tau_ff_gain =\r\n      buildover_fullstatemachine_P.Constant2_Value_o;\r\n    *Tune_ID = buildover_fullstatemachine_P.Constant7_Value_p;\r\n    *arm_output = buildover_fullstatemachine_P.Constant13_Value_o;\r\n  }\r\n}\r\n\r\nstatic void buildover_fullstatema_off_armed(boolean_T *arm_output, real_T\r\n  *Tune_ID, real_T *slider_position, const uint16_T *uDLookupTable6, real_T\r\n  *w_ff_gain, const real_T *CastToDouble)\r\n{\r\n  switch (*uDLookupTable6) {\r\n   case 2:\r\n    buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n      buildover_fullsta_IN_Quad_Hover;\r\n    buildover_fullstatemachine_B.lcb_speed =\r\n      buildover_fullstatemachine_P.Constant3_Value_j;\r\n    buildover_fullstatemachine_B.mainrotor_control =\r\n      buildover_fullstatemachine_P.Constant4_Value_g;\r\n    buildover_fullstatemachine_B.rcb_speed =\r\n      buildover_fullstatemachine_P.Constant5_Value_p;\r\n    buildover_fullstatemachine_B.rightcb_angle =\r\n      buildover_fullstatemachine_P.Constant1_Value_dz;\r\n    buildover_fullstatemachine_B.leftcb_angle =\r\n      buildover_fullstatemachine_P.Constant14_Value;\r\n    *slider_position = buildover_fullstatemachine_P.Constant7_Value_e;\r\n    *w_ff_gain = buildover_fullstatemachine_P.Constant2_Value_b;\r\n    buildover_fullstatemachine_B.tau_ff_gain =\r\n      buildover_fullstatemachine_P.Constant6_Value_p;\r\n    *Tune_ID = buildover_fullstatemachine_P.Constant8_Value_c;\r\n    *arm_output = buildover_fullstatemachine_P.Constant13_Value_p;\r\n    break;\r\n\r\n   case 4:\r\n    buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n      buildover_full_IN_Rotor_Spin_Up;\r\n    buildover_fullstatemachine_B.lcb_speed =\r\n      buildover_fullstatemachine_P.Constant6_Value_cy;\r\n    buildover_fullstatemachine_B.mainrotor_control =\r\n      buildover_fullstatemachine_P.Constant_Value_as;\r\n    buildover_fullstatemachine_B.rcb_speed =\r\n      buildover_fullstatemachine_P.Constant5_Value_n;\r\n    buildover_fullstatemachine_B.rightcb_angle =\r\n      buildover_fullstatemachine_P.Constant1_Value_g;\r\n    buildover_fullstatemachine_B.leftcb_angle =\r\n      buildover_fullstatemachine_P.Constant3_Value_j5;\r\n    *slider_position = buildover_fullstatemachine_P.Constant2_Value_oh;\r\n    *w_ff_gain = buildover_fullstatemachine_P.Constant4_Value_d;\r\n    buildover_fullstatemachine_B.tau_ff_gain =\r\n      buildover_fullstatemachine_P.Constant11_Value;\r\n    *Tune_ID = buildover_fullstatemachine_P.Constant7_Value_j;\r\n    *arm_output = buildover_fullstatemachine_P.Constant13_Value_kn;\r\n    break;\r\n\r\n   default:\r\n    if (*CastToDouble == 0.0) {\r\n      buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n        buildover_fulls_IN_off_disarmed;\r\n      *w_ff_gain = buildover_fullstatemachine_P.Constant12_Value_d;\r\n      buildover_fullstatemachine_B.tau_ff_gain =\r\n        buildover_fullstatemachine_P.Constant1_Value_o;\r\n      *Tune_ID = buildover_fullstatemachine_P.Constant11_Value_c;\r\n      buildover_fullstatemachine_B.lcb_speed =\r\n        buildover_fullstatemachine_P.Constant2_Value_o4;\r\n      buildover_fullstatemachine_B.rcb_speed =\r\n        buildover_fullstatemachine_P.Constant2_Value_o4;\r\n      buildover_fullstatemachine_B.mainrotor_control =\r\n        buildover_fullstatemachine_P.Constant3_Value_l;\r\n      buildover_fullstatemachine_B.leftcb_angle =\r\n        buildover_fullstatemachine_P.Constant4_Value_i;\r\n      buildover_fullstatemachine_B.rightcb_angle =\r\n        buildover_fullstatemachine_P.Constant4_Value_i;\r\n      *slider_position = buildover_fullstatemachine_P.Constant6_Value_b;\r\n      *arm_output = buildover_fullstatemachine_P.Constant13_Value_f;\r\n    } else if (buildover_fullstatemachine_B.CastToDouble16 == 1.0) {\r\n      buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n        buildover_fullstatemach_IN_Kill;\r\n      buildover_fullstatemachine_B.lcb_speed =\r\n        buildover_fullstatemachine_P.Constant_Value_fc;\r\n      buildover_fullstatemachine_B.leftcb_angle =\r\n        buildover_fullstatemachine_P.Constant_Value_fc;\r\n      buildover_fullstatemachine_B.mainrotor_control =\r\n        buildover_fullstatemachine_P.Constant_Value_fc;\r\n      buildover_fullstatemachine_B.rcb_speed =\r\n        buildover_fullstatemachine_P.Constant_Value_fc;\r\n      buildover_fullstatemachine_B.rightcb_angle =\r\n        buildover_fullstatemachine_P.Constant_Value_fc;\r\n      *slider_position = buildover_fullstatemachine_P.Constant_Value_fc;\r\n      buildover_fullstatemachine_B.tau_ff_gain =\r\n        buildover_fullstatemachine_P.Constant_Value_fc;\r\n      *w_ff_gain = buildover_fullstatemachine_P.Constant_Value_fc;\r\n      *Tune_ID = buildover_fullstatemachine_P.Constant13_Value;\r\n      *arm_output = buildover_fullstatemachine_P.Constant1_Value_a;\r\n    } else {\r\n      buildover_fullstatemachine_B.lcb_speed =\r\n        buildover_fullstatemachine_P.Constant2_Value_h;\r\n      buildover_fullstatemachine_B.rcb_speed =\r\n        buildover_fullstatemachine_P.Constant2_Value_h;\r\n      buildover_fullstatemachine_B.mainrotor_control =\r\n        buildover_fullstatemachine_P.Constant3_Value_jc;\r\n      buildover_fullstatemachine_B.rightcb_angle =\r\n        buildover_fullstatemachine_P.Constant4_Value_e;\r\n      buildover_fullstatemachine_B.leftcb_angle =\r\n        buildover_fullstatemachine_P.Constant14_Value_f;\r\n      *slider_position = buildover_fullstatemachine_P.Constant6_Value_f5;\r\n      *w_ff_gain = buildover_fullstatemachine_P.Constant12_Value_j;\r\n      buildover_fullstatemachine_B.tau_ff_gain =\r\n        buildover_fullstatemachine_P.Constant1_Value_ly;\r\n      *Tune_ID = buildover_fullstatemachine_P.Constant11_Value_a;\r\n      *arm_output = buildover_fullstatemachine_P.Constant13_Value_d;\r\n    }\r\n    break;\r\n  }\r\n}\r\n\r\nstatic real_T buildover_fullstatemachine_norm(const real_T x[4])\r\n{\r\n  real_T absxk;\r\n  real_T scale;\r\n  real_T t;\r\n  real_T y;\r\n  scale = 3.3121686421112381E-170;\r\n  absxk = fabs(x[0]);\r\n  if (absxk > 3.3121686421112381E-170) {\r\n    y = 1.0;\r\n    scale = absxk;\r\n  } else {\r\n    t = absxk / 3.3121686421112381E-170;\r\n    y = t * t;\r\n  }\r\n\r\n  absxk = fabs(x[1]);\r\n  if (absxk > scale) {\r\n    t = scale / absxk;\r\n    y = y * t * t + 1.0;\r\n    scale = absxk;\r\n  } else {\r\n    t = absxk / scale;\r\n    y += t * t;\r\n  }\r\n\r\n  absxk = fabs(x[2]);\r\n  if (absxk > scale) {\r\n    t = scale / absxk;\r\n    y = y * t * t + 1.0;\r\n    scale = absxk;\r\n  } else {\r\n    t = absxk / scale;\r\n    y += t * t;\r\n  }\r\n\r\n  absxk = fabs(x[3]);\r\n  if (absxk > scale) {\r\n    t = scale / absxk;\r\n    y = y * t * t + 1.0;\r\n    scale = absxk;\r\n  } else {\r\n    t = absxk / scale;\r\n    y += t * t;\r\n  }\r\n\r\n  return scale * sqrt(y);\r\n}\r\n\r\nreal_T rt_atan2d_snf(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  if (rtIsNaN(u0) || rtIsNaN(u1)) {\r\n    y = (rtNaN);\r\n  } else if (rtIsInf(u0) && rtIsInf(u1)) {\r\n    int32_T tmp;\r\n    int32_T tmp_0;\r\n    if (u0 > 0.0) {\r\n      tmp = 1;\r\n    } else {\r\n      tmp = -1;\r\n    }\r\n\r\n    if (u1 > 0.0) {\r\n      tmp_0 = 1;\r\n    } else {\r\n      tmp_0 = -1;\r\n    }\r\n\r\n    y = atan2(static_cast<real_T>(tmp), static_cast<real_T>(tmp_0));\r\n  } else if (u1 == 0.0) {\r\n    if (u0 > 0.0) {\r\n      y = RT_PI / 2.0;\r\n    } else if (u0 < 0.0) {\r\n      y = -(RT_PI / 2.0);\r\n    } else {\r\n      y = 0.0;\r\n    }\r\n  } else {\r\n    y = atan2(u0, u1);\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\nstatic void buildover_fullstat_expand_atan2(const real_T a_data[], const int32_T\r\n  *a_size, const real_T b_data[], const int32_T *b_size, real_T c_data[],\r\n  int32_T *c_size)\r\n{\r\n  int32_T csz_idx_0;\r\n  if (*b_size == 1) {\r\n    csz_idx_0 = *a_size;\r\n  } else {\r\n    csz_idx_0 = 0;\r\n  }\r\n\r\n  *c_size = csz_idx_0;\r\n  if (csz_idx_0 != 0) {\r\n    c_data[0] = rt_atan2d_snf(a_data[0], b_data[0]);\r\n  }\r\n}\r\n\r\nstatic void buildover_full_binary_expand_op(real_T in1[3], const int32_T\r\n  in2_data[], const real_T in3_data[], const int32_T *in3_size, const real_T\r\n  in4_data[], const int32_T *in4_size)\r\n{\r\n  int32_T loop_ub;\r\n  loop_ub = *in4_size == 1 ? *in3_size : *in4_size;\r\n  for (int32_T i = 0; i < loop_ub; i++) {\r\n    in1[in2_data[0]] = -in3_data[0] * 2.0 * in4_data[0];\r\n  }\r\n}\r\n\r\nstatic void buildover_full_SystemCore_setup(px4_internal_block_PWM_buildo_T *obj,\r\n  boolean_T varargin_1, boolean_T varargin_2)\r\n{\r\n  uint16_T status;\r\n  obj->isSetupComplete = false;\r\n  obj->isInitialized = 1;\r\n  obj->isMain = true;\r\n  obj->pwmDevObj = MW_PWM_OUTPUT_MAIN_DEVICE_PATH;\r\n  status = pwm_open(&obj->pwmDevHandler, obj->pwmDevObj,\r\n                    &obj->actuatorAdvertiseObj, &obj->armAdvertiseObj);\r\n  obj->errorStatus = static_cast<uint16_T>(obj->errorStatus | status);\r\n  obj->servoCount = 0;\r\n  status = pwm_getServoCount(&obj->pwmDevHandler, &obj->servoCount);\r\n  obj->errorStatus = static_cast<uint16_T>(obj->errorStatus | status);\r\n  if (varargin_1) {\r\n    status = pwm_arm(&obj->pwmDevHandler, &obj->armAdvertiseObj);\r\n    obj->isArmed = true;\r\n  } else {\r\n    status = pwm_disarm(&obj->pwmDevHandler, &obj->armAdvertiseObj);\r\n    obj->isArmed = false;\r\n  }\r\n\r\n  obj->errorStatus = static_cast<uint16_T>(obj->errorStatus | status);\r\n  status = pwm_setPWMRate(&obj->pwmDevHandler, obj->isMain);\r\n  obj->errorStatus = static_cast<uint16_T>(obj->errorStatus | status);\r\n  obj->channelMask = 63;\r\n  status = pwm_setChannelMask(&obj->pwmDevHandler, obj->channelMask);\r\n  obj->errorStatus = static_cast<uint16_T>(obj->errorStatus | status);\r\n  status = pwm_setFailsafePWM(&obj->pwmDevHandler, obj->servoCount,\r\n    obj->channelMask, obj->isMain);\r\n  obj->errorStatus = static_cast<uint16_T>(obj->errorStatus | status);\r\n  status = pwm_setDisarmedPWM(&obj->pwmDevHandler, obj->servoCount,\r\n    obj->channelMask, obj->isMain, &obj->actuatorAdvertiseObj);\r\n  obj->errorStatus = static_cast<uint16_T>(obj->errorStatus | status);\r\n  if (obj->isMain) {\r\n    status = pwm_forceFailsafe(&obj->pwmDevHandler, static_cast<int32_T>\r\n      (varargin_2));\r\n    obj->errorStatus = static_cast<uint16_T>(obj->errorStatus | status);\r\n    status = pwm_forceTerminateFailsafe(&obj->pwmDevHandler, 0);\r\n    obj->errorStatus = static_cast<uint16_T>(obj->errorStatus | status);\r\n  }\r\n\r\n  obj->isSetupComplete = true;\r\n}\r\n\r\nvoid buildover_fullstatemachine_step(void)\r\n{\r\n  real_T b_idx_0;\r\n  real_T out_tmp;\r\n  real_T out_tmp_0;\r\n  real_T out_tmp_1;\r\n  real_T u0_tmp;\r\n  real_T y_idx_2;\r\n  int32_T f_size_idx_0;\r\n  int32_T g_size_idx_0;\r\n  int32_T h_size_idx_0;\r\n  int32_T k;\r\n  int32_T tmp_data;\r\n  int32_T trueCount;\r\n  uint16_T uDLookupTable6;\r\n  boolean_T x[4];\r\n  boolean_T NOT1;\r\n  boolean_T exitg1;\r\n  boolean_T mask1;\r\n  ZCEventType zcEvent;\r\n  mask1 = uORB_read_step(buildover_fullstatemachine_DW.obj_l.orbMetadataObj,\r\n    &buildover_fullstatemachine_DW.obj_l.eventStructObj,\r\n    &buildover_fullstatemachine_B.b_varargout_2_m, false, 5000.0);\r\n  if (mask1) {\r\n    buildover_fullstatemachine_B.In1_m =\r\n      buildover_fullstatemachine_B.b_varargout_2_m;\r\n  }\r\n\r\n  if (buildover_fullstatemachine_B.In1_m.values[6] >\r\n      buildover_fullstatemachine_P.WrapToZero1_Threshold) {\r\n    buildover_fullstatemachine_B.CastToDouble =\r\n      (buildover_fullstatemachine_P.Constant_Value_j == 0);\r\n  } else {\r\n    buildover_fullstatemachine_B.CastToDouble =\r\n      (buildover_fullstatemachine_B.In1_m.values[6] == 0);\r\n  }\r\n\r\n  if (buildover_fullstatemachine_B.In1_m.values[7] >\r\n      buildover_fullstatemachine_P.WrapToZero_Threshold) {\r\n    buildover_fullstatemachine_B.CastToDouble16 =\r\n      (buildover_fullstatemachine_P.Constant_Value_k == 0);\r\n  } else {\r\n    buildover_fullstatemachine_B.CastToDouble16 =\r\n      (buildover_fullstatemachine_B.In1_m.values[7] == 0);\r\n  }\r\n\r\n  uDLookupTable6 =\r\n    buildover_fullstatemachine_P.uDLookupTable6_tableData[plook_u32u16_bincka\r\n    (buildover_fullstatemachine_B.In1_m.values[5],\r\n     buildover_fullstatemachine_P.uDLookupTable6_bp01Data, 6U)];\r\n  if (buildover_fullstatemachine_DW.Memory_PreviousInput >\r\n      buildover_fullstatemachine_P.Saturation7_UpperSat) {\r\n    buildover_fullstatemachine_B.Saturation =\r\n      buildover_fullstatemachine_P.Saturation7_UpperSat;\r\n  } else if (buildover_fullstatemachine_DW.Memory_PreviousInput <\r\n             buildover_fullstatemachine_P.Saturation7_LowerSat) {\r\n    buildover_fullstatemachine_B.Saturation =\r\n      buildover_fullstatemachine_P.Saturation7_LowerSat;\r\n  } else {\r\n    buildover_fullstatemachine_B.Saturation =\r\n      buildover_fullstatemachine_DW.Memory_PreviousInput;\r\n  }\r\n\r\n  buildover_fullstatemachine_B.RateLimiter1_f =\r\n    buildover_fullstatemachine_B.Saturation -\r\n    buildover_fullstatemachine_DW.PrevY;\r\n  if (buildover_fullstatemachine_B.RateLimiter1_f >\r\n      buildover_fullstatemachine_P.RateLimiter_RisingLim *\r\n      buildover_fullstatemachi_period) {\r\n    buildover_fullstatemachine_B.Saturation =\r\n      buildover_fullstatemachine_P.RateLimiter_RisingLim *\r\n      buildover_fullstatemachi_period + buildover_fullstatemachine_DW.PrevY;\r\n  } else if (buildover_fullstatemachine_B.RateLimiter1_f <\r\n             buildover_fullstatemachine_P.RateLimiter_FallingLim *\r\n             buildover_fullstatemachi_period) {\r\n    buildover_fullstatemachine_B.Saturation =\r\n      buildover_fullstatemachine_P.RateLimiter_FallingLim *\r\n      buildover_fullstatemachi_period + buildover_fullstatemachine_DW.PrevY;\r\n  }\r\n\r\n  buildover_fullstatemachine_DW.PrevY = buildover_fullstatemachine_B.Saturation;\r\n  buildover_fullstatemachine_B.TSamp = buildover_fullstatemachine_B.Saturation *\r\n    buildover_fullstatemachine_P.TSamp_WtEt;\r\n  buildover_fullstatemachine_B.Diff = buildover_fullstatemachine_B.TSamp -\r\n    buildover_fullstatemachine_DW.UD_DSTATE;\r\n  buildover_fullstatemachine_B.TSamp_o =\r\n    buildover_fullstatemachine_DW.Memory_PreviousInput_d *\r\n    buildover_fullstatemachine_P.TSamp_WtEt_m;\r\n  buildover_fullstatemachine_B.Diff_l = buildover_fullstatemachine_B.TSamp_o -\r\n    buildover_fullstatemachine_DW.UD_DSTATE_d;\r\n  buildover_fullstatemachine_B.TSamp_g =\r\n    buildover_fullstatemachine_DW.Memory1_PreviousInput *\r\n    buildover_fullstatemachine_P.TSamp_WtEt_e;\r\n  buildover_fullstatemachine_B.Diff_g = buildover_fullstatemachine_B.TSamp_g -\r\n    buildover_fullstatemachine_DW.UD_DSTATE_f;\r\n  mask1 = uORB_read_step(buildover_fullstatemachine_DW.obj_b.orbMetadataObj,\r\n    &buildover_fullstatemachine_DW.obj_b.eventStructObj,\r\n    &buildover_fullstatemachine_B.b_varargout_2_m, false, 1.0);\r\n  if (mask1) {\r\n    buildover_fullstatemachine_B.In1_n =\r\n      buildover_fullstatemachine_B.b_varargout_2_m;\r\n  }\r\n\r\n  if (buildover_fullstatemachine_B.In1_n.values[8] >\r\n      buildover_fullstatemachine_P.WrapToZero1_Threshold_j) {\r\n    NOT1 = (buildover_fullstatemachine_P.Constant_Value_p1 == 0);\r\n  } else {\r\n    NOT1 = (buildover_fullstatemachine_B.In1_n.values[8] == 0);\r\n  }\r\n\r\n  buildover_fullstatemachine_B.Switch = look1_binlxpw(static_cast<real_T>\r\n    (buildover_fullstatemachine_B.In1_m.values[2]),\r\n    buildover_fullstatemachine_P.uDLookupTable1_bp01Data_g,\r\n    buildover_fullstatemachine_P.uDLookupTable1_tableData_b, 1U);\r\n  if (buildover_fullstatemachine_B.Switch >\r\n      buildover_fullstatemachine_P.Saturation_UpperSat) {\r\n    buildover_fullstatemachine_B.Switch =\r\n      buildover_fullstatemachine_P.Saturation_UpperSat;\r\n  } else if (buildover_fullstatemachine_B.Switch <\r\n             buildover_fullstatemachine_P.Saturation_LowerSat) {\r\n    buildover_fullstatemachine_B.Switch =\r\n      buildover_fullstatemachine_P.Saturation_LowerSat;\r\n  }\r\n\r\n  if (buildover_fullstatemachine_B.Switch >\r\n      buildover_fullstatemachine_P.DeadZone_End) {\r\n    buildover_fullstatemachine_B.Switch -=\r\n      buildover_fullstatemachine_P.DeadZone_End;\r\n  } else if (buildover_fullstatemachine_B.Switch >=\r\n             buildover_fullstatemachine_P.DeadZone_Start) {\r\n    buildover_fullstatemachine_B.Switch = 0.0;\r\n  } else {\r\n    buildover_fullstatemachine_B.Switch -=\r\n      buildover_fullstatemachine_P.DeadZone_Start;\r\n  }\r\n\r\n  if (buildover_fullstatemachine_DW.is_active_c3_buildover_fullstat == 0U) {\r\n    buildover_fullstatemachine_DW.is_active_c3_buildover_fullstat = 1U;\r\n    buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n      buildover_fulls_IN_off_disarmed;\r\n    buildover_fullstatemachine_B.w_ff_gain =\r\n      buildover_fullstatemachine_P.Constant12_Value_d;\r\n    buildover_fullstatemachine_B.tau_ff_gain =\r\n      buildover_fullstatemachine_P.Constant1_Value_o;\r\n    buildover_fullstatemachine_B.Diff_l =\r\n      buildover_fullstatemachine_P.Constant11_Value_c;\r\n    buildover_fullstatemachine_B.lcb_speed =\r\n      buildover_fullstatemachine_P.Constant2_Value_o4;\r\n    buildover_fullstatemachine_B.rcb_speed =\r\n      buildover_fullstatemachine_P.Constant2_Value_o4;\r\n    buildover_fullstatemachine_B.mainrotor_control =\r\n      buildover_fullstatemachine_P.Constant3_Value_l;\r\n    buildover_fullstatemachine_B.leftcb_angle =\r\n      buildover_fullstatemachine_P.Constant4_Value_i;\r\n    buildover_fullstatemachine_B.rightcb_angle =\r\n      buildover_fullstatemachine_P.Constant4_Value_i;\r\n    buildover_fullstatemachine_B.Diff_g =\r\n      buildover_fullstatemachine_P.Constant6_Value_b;\r\n    NOT1 = buildover_fullstatemachine_P.Constant13_Value_f;\r\n  } else {\r\n    switch (buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin) {\r\n     case buildover_ful_IN_FF_Preparation:\r\n      if (buildover_fullstatemachine_B.CastToDouble16 == 1.0) {\r\n        buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n          buildover_fullstatemach_IN_Kill;\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant13_Value;\r\n        NOT1 = buildover_fullstatemachine_P.Constant1_Value_a;\r\n      } else if (uDLookupTable6 == 2) {\r\n        buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n          buildover_fullsta_IN_Quad_Hover;\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant3_Value_j;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant4_Value_g;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant5_Value_p;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant1_Value_dz;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant14_Value;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant7_Value_e;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant2_Value_b;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant6_Value_p;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant8_Value_c;\r\n        NOT1 = buildover_fullstatemachine_P.Constant13_Value_p;\r\n      } else if (NOT1 && (fabs(buildover_fullstatemachine_B.Diff_g) < 100.0) &&\r\n                 (fabs(buildover_fullstatemachine_B.Diff_l) < 100.0)) {\r\n        buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n          buildover_ful_IN_Forward_Flight;\r\n        buildover_fullstatemachine_B.Switch = look1_binlxpw\r\n          (buildover_fullstatemachine_B.Switch,\r\n           buildover_fullstatemachine_P.uDLookupTable1_bp01Data,\r\n           buildover_fullstatemachine_P.uDLookupTable1_tableData, 1U);\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_B.Switch;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_B.Switch;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant3_Value_a;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant9_Value_e;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant10_Value;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant4_Value_m;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant12_Value;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant2_Value;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant1_Value_d;\r\n        NOT1 = buildover_fullstatemachine_P.Constant13_Value_k;\r\n      } else {\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant_Value_e;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant4_Value;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant3_Value;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant5_Value;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant1_Value;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant9_Value;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant6_Value;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant7_Value;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant8_Value;\r\n        NOT1 = buildover_fullstatemachine_P.Constant13_Value_j;\r\n      }\r\n      break;\r\n\r\n     case buildover_ful_IN_Forward_Flight:\r\n      if (buildover_fullstatemachine_B.CastToDouble16 == 1.0) {\r\n        buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n          buildover_fullstatemach_IN_Kill;\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant13_Value;\r\n        NOT1 = buildover_fullstatemachine_P.Constant1_Value_a;\r\n      } else if (!NOT1) {\r\n        buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n          buildover_ful_IN_FF_Preparation;\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant_Value_e;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant4_Value;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant3_Value;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant5_Value;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant1_Value;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant9_Value;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant6_Value;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant7_Value;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant8_Value;\r\n        NOT1 = buildover_fullstatemachine_P.Constant13_Value_j;\r\n      } else {\r\n        buildover_fullstatemachine_B.Switch = look1_binlxpw\r\n          (buildover_fullstatemachine_B.Switch,\r\n           buildover_fullstatemachine_P.uDLookupTable1_bp01Data,\r\n           buildover_fullstatemachine_P.uDLookupTable1_tableData, 1U);\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_B.Switch;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_B.Switch;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant3_Value_a;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant9_Value_e;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant10_Value;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant4_Value_m;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant12_Value;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant2_Value;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant1_Value_d;\r\n        NOT1 = buildover_fullstatemachine_P.Constant13_Value_k;\r\n      }\r\n      break;\r\n\r\n     case buildover_fullstatemach_IN_Kill:\r\n      if ((buildover_fullstatemachine_B.CastToDouble16 == 0.0) &&\r\n          (buildover_fullstatemachine_B.CastToDouble == 0.0)) {\r\n        buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n          buildover_fulls_IN_off_disarmed;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant12_Value_d;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant1_Value_o;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant11_Value_c;\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant2_Value_o4;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant2_Value_o4;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant3_Value_l;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant4_Value_i;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant4_Value_i;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant6_Value_b;\r\n        NOT1 = buildover_fullstatemachine_P.Constant13_Value_f;\r\n      } else {\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant13_Value;\r\n        NOT1 = buildover_fullstatemachine_P.Constant1_Value_a;\r\n      }\r\n      break;\r\n\r\n     case buildover_fullsta_IN_Quad_Hover:\r\n      switch (uDLookupTable6) {\r\n       case 4:\r\n        buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n          buildover_fullst_IN_Rotor_ACCEL;\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant6_Value_pc;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant4_Value_mr;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant5_Value_j;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant3_Value_g;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant14_Value_c;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant_Value_fp;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant1_Value_l;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant2_Value_j;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant7_Value_l;\r\n        NOT1 = buildover_fullstatemachine_P.Constant13_Value_a;\r\n        break;\r\n\r\n       case 7:\r\n        buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n          buildover_fulls_IN_off_disarmed;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant12_Value_d;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant1_Value_o;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant11_Value_c;\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant2_Value_o4;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant2_Value_o4;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant3_Value_l;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant4_Value_i;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant4_Value_i;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant6_Value_b;\r\n        NOT1 = buildover_fullstatemachine_P.Constant13_Value_f;\r\n        break;\r\n\r\n       default:\r\n        if (buildover_fullstatemachine_B.CastToDouble16 == 1.0) {\r\n          buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n            buildover_fullstatemach_IN_Kill;\r\n          buildover_fullstatemachine_B.lcb_speed =\r\n            buildover_fullstatemachine_P.Constant_Value_fc;\r\n          buildover_fullstatemachine_B.leftcb_angle =\r\n            buildover_fullstatemachine_P.Constant_Value_fc;\r\n          buildover_fullstatemachine_B.mainrotor_control =\r\n            buildover_fullstatemachine_P.Constant_Value_fc;\r\n          buildover_fullstatemachine_B.rcb_speed =\r\n            buildover_fullstatemachine_P.Constant_Value_fc;\r\n          buildover_fullstatemachine_B.rightcb_angle =\r\n            buildover_fullstatemachine_P.Constant_Value_fc;\r\n          buildover_fullstatemachine_B.Diff_g =\r\n            buildover_fullstatemachine_P.Constant_Value_fc;\r\n          buildover_fullstatemachine_B.tau_ff_gain =\r\n            buildover_fullstatemachine_P.Constant_Value_fc;\r\n          buildover_fullstatemachine_B.w_ff_gain =\r\n            buildover_fullstatemachine_P.Constant_Value_fc;\r\n          buildover_fullstatemachine_B.Diff_l =\r\n            buildover_fullstatemachine_P.Constant13_Value;\r\n          NOT1 = buildover_fullstatemachine_P.Constant1_Value_a;\r\n        } else if (uDLookupTable6 == 6) {\r\n          buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n            buildover_ful_IN_FF_Preparation;\r\n          buildover_fullstatemachine_B.lcb_speed =\r\n            buildover_fullstatemachine_P.Constant_Value_e;\r\n          buildover_fullstatemachine_B.mainrotor_control =\r\n            buildover_fullstatemachine_P.Constant4_Value;\r\n          buildover_fullstatemachine_B.rcb_speed =\r\n            buildover_fullstatemachine_P.Constant3_Value;\r\n          buildover_fullstatemachine_B.rightcb_angle =\r\n            buildover_fullstatemachine_P.Constant5_Value;\r\n          buildover_fullstatemachine_B.leftcb_angle =\r\n            buildover_fullstatemachine_P.Constant1_Value;\r\n          buildover_fullstatemachine_B.Diff_g =\r\n            buildover_fullstatemachine_P.Constant9_Value;\r\n          buildover_fullstatemachine_B.w_ff_gain =\r\n            buildover_fullstatemachine_P.Constant6_Value;\r\n          buildover_fullstatemachine_B.tau_ff_gain =\r\n            buildover_fullstatemachine_P.Constant7_Value;\r\n          buildover_fullstatemachine_B.Diff_l =\r\n            buildover_fullstatemachine_P.Constant8_Value;\r\n          NOT1 = buildover_fullstatemachine_P.Constant13_Value_j;\r\n        } else {\r\n          buildover_fullstatemachine_B.lcb_speed =\r\n            buildover_fullstatemachine_P.Constant3_Value_j;\r\n          buildover_fullstatemachine_B.mainrotor_control =\r\n            buildover_fullstatemachine_P.Constant4_Value_g;\r\n          buildover_fullstatemachine_B.rcb_speed =\r\n            buildover_fullstatemachine_P.Constant5_Value_p;\r\n          buildover_fullstatemachine_B.rightcb_angle =\r\n            buildover_fullstatemachine_P.Constant1_Value_dz;\r\n          buildover_fullstatemachine_B.leftcb_angle =\r\n            buildover_fullstatemachine_P.Constant14_Value;\r\n          buildover_fullstatemachine_B.Diff_g =\r\n            buildover_fullstatemachine_P.Constant7_Value_e;\r\n          buildover_fullstatemachine_B.w_ff_gain =\r\n            buildover_fullstatemachine_P.Constant2_Value_b;\r\n          buildover_fullstatemachine_B.tau_ff_gain =\r\n            buildover_fullstatemachine_P.Constant6_Value_p;\r\n          buildover_fullstatemachine_B.Diff_l =\r\n            buildover_fullstatemachine_P.Constant8_Value_c;\r\n          NOT1 = buildover_fullstatemachine_P.Constant13_Value_p;\r\n        }\r\n        break;\r\n      }\r\n      break;\r\n\r\n     case buildover_fullst_IN_Rotor_ACCEL:\r\n      if (buildover_fullstatemachine_B.Diff == 0.0) {\r\n        buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n          buildover_fullstatemach_IN_VTOL;\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant6_Value_pg;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant3_Value_af;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant5_Value_a;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant4_Value_gr;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant12_Value_e;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant_Value_h;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant1_Value_p;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant2_Value_bd;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant7_Value_e1;\r\n        NOT1 = buildover_fullstatemachine_P.Constant13_Value_l;\r\n      } else if ((uDLookupTable6 == 2) || (uDLookupTable6 == 6)) {\r\n        buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n          buildover_IN_Rotor_DEACCEL_prep;\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant4_Value_l;\r\n        buildover_fullstatemachine_B.Switch =\r\n          buildover_fullstatemachine_P.Constant2_Value_i -\r\n          buildover_fullstatemachine_DW.DiscreteTimeIntegrator_DSTATE;\r\n        if (buildover_fullstatemachine_B.Switch >\r\n            buildover_fullstatemachine_P.Saturation6_UpperSat) {\r\n          buildover_fullstatemachine_B.mainrotor_control =\r\n            buildover_fullstatemachine_P.Saturation6_UpperSat;\r\n        } else if (buildover_fullstatemachine_B.Switch <\r\n                   buildover_fullstatemachine_P.Saturation6_LowerSat) {\r\n          buildover_fullstatemachine_B.mainrotor_control =\r\n            buildover_fullstatemachine_P.Saturation6_LowerSat;\r\n        } else {\r\n          buildover_fullstatemachine_B.mainrotor_control =\r\n            buildover_fullstatemachine_B.Switch;\r\n        }\r\n\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant5_Value_f;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant3_Value_p;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant14_Value_ch;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant_Value_a;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant12_Value_p;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant1_Value_k;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant6_Value_f;\r\n        NOT1 = buildover_fullstatemachine_P.Constant13_Value_n;\r\n        buildover_fullstatemachine_DW.DiscreteTimeIntegrator_DSTATE +=\r\n          buildover_fullstatemachine_B.Switch *\r\n          buildover_fullstatemachine_B.Switch *\r\n          buildover_fullstatemachine_P.Constant7_Value_o *\r\n          buildover_fullstatemachine_P.DiscreteTimeIntegrator_gainval;\r\n        if (buildover_fullstatemachine_DW.DiscreteTimeIntegrator_DSTATE >=\r\n            buildover_fullstatemachine_P.DiscreteTimeIntegrator_UpperSat) {\r\n          buildover_fullstatemachine_DW.DiscreteTimeIntegrator_DSTATE =\r\n            buildover_fullstatemachine_P.DiscreteTimeIntegrator_UpperSat;\r\n        } else if (buildover_fullstatemachine_DW.DiscreteTimeIntegrator_DSTATE <=\r\n                   buildover_fullstatemachine_P.DiscreteTimeIntegrator_LowerSat)\r\n        {\r\n          buildover_fullstatemachine_DW.DiscreteTimeIntegrator_DSTATE =\r\n            buildover_fullstatemachine_P.DiscreteTimeIntegrator_LowerSat;\r\n        }\r\n      } else if (buildover_fullstatemachine_B.CastToDouble16 == 1.0) {\r\n        buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n          buildover_fullstatemach_IN_Kill;\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant13_Value;\r\n        NOT1 = buildover_fullstatemachine_P.Constant1_Value_a;\r\n      } else {\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant6_Value_pc;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant4_Value_mr;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant5_Value_j;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant3_Value_g;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant14_Value_c;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant_Value_fp;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant1_Value_l;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant2_Value_j;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant7_Value_l;\r\n        NOT1 = buildover_fullstatemachine_P.Constant13_Value_a;\r\n      }\r\n      break;\r\n\r\n     case buildover_full_IN_Rotor_DEACCEL:\r\n      buildover_fullsta_Rotor_DEACCEL(&NOT1,\r\n        &buildover_fullstatemachine_B.Diff_l,\r\n        &buildover_fullstatemachine_B.Diff_g, &uDLookupTable6,\r\n        &buildover_fullstatemachine_B.Diff,\r\n        &buildover_fullstatemachine_B.w_ff_gain);\r\n      break;\r\n\r\n     case buildover_IN_Rotor_DEACCEL_prep:\r\n      if (buildover_fullstatemachine_B.CastToDouble16 == 1.0) {\r\n        buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n          buildover_fullstatemach_IN_Kill;\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant13_Value;\r\n        NOT1 = buildover_fullstatemachine_P.Constant1_Value_a;\r\n      } else if ((fabs(buildover_fullstatemachine_B.Diff_g) < 100.0) && (fabs\r\n                  (buildover_fullstatemachine_B.Diff_l) < 100.0)) {\r\n        buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n          buildover_full_IN_Rotor_DEACCEL;\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant6_Value_c;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant5_Value_l;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant4_Value_o;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant3_Value_e;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant14_Value_i;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant_Value_ml;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant1_Value_n;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant2_Value_o;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant7_Value_p;\r\n        NOT1 = buildover_fullstatemachine_P.Constant13_Value_o;\r\n      } else {\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant4_Value_l;\r\n        buildover_fullstatemachine_B.Switch =\r\n          buildover_fullstatemachine_P.Constant2_Value_i -\r\n          buildover_fullstatemachine_DW.DiscreteTimeIntegrator_DSTATE;\r\n        if (buildover_fullstatemachine_B.Switch >\r\n            buildover_fullstatemachine_P.Saturation6_UpperSat) {\r\n          buildover_fullstatemachine_B.mainrotor_control =\r\n            buildover_fullstatemachine_P.Saturation6_UpperSat;\r\n        } else if (buildover_fullstatemachine_B.Switch <\r\n                   buildover_fullstatemachine_P.Saturation6_LowerSat) {\r\n          buildover_fullstatemachine_B.mainrotor_control =\r\n            buildover_fullstatemachine_P.Saturation6_LowerSat;\r\n        } else {\r\n          buildover_fullstatemachine_B.mainrotor_control =\r\n            buildover_fullstatemachine_B.Switch;\r\n        }\r\n\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant5_Value_f;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant3_Value_p;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant14_Value_ch;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant_Value_a;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant12_Value_p;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant1_Value_k;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant6_Value_f;\r\n        NOT1 = buildover_fullstatemachine_P.Constant13_Value_n;\r\n        buildover_fullstatemachine_DW.DiscreteTimeIntegrator_DSTATE +=\r\n          buildover_fullstatemachine_B.Switch *\r\n          buildover_fullstatemachine_B.Switch *\r\n          buildover_fullstatemachine_P.Constant7_Value_o *\r\n          buildover_fullstatemachine_P.DiscreteTimeIntegrator_gainval;\r\n        if (buildover_fullstatemachine_DW.DiscreteTimeIntegrator_DSTATE >=\r\n            buildover_fullstatemachine_P.DiscreteTimeIntegrator_UpperSat) {\r\n          buildover_fullstatemachine_DW.DiscreteTimeIntegrator_DSTATE =\r\n            buildover_fullstatemachine_P.DiscreteTimeIntegrator_UpperSat;\r\n        } else if (buildover_fullstatemachine_DW.DiscreteTimeIntegrator_DSTATE <=\r\n                   buildover_fullstatemachine_P.DiscreteTimeIntegrator_LowerSat)\r\n        {\r\n          buildover_fullstatemachine_DW.DiscreteTimeIntegrator_DSTATE =\r\n            buildover_fullstatemachine_P.DiscreteTimeIntegrator_LowerSat;\r\n        }\r\n      }\r\n      break;\r\n\r\n     case buildover_full_IN_Rotor_Spin_Up:\r\n      if (buildover_fullstatemachine_B.CastToDouble16 == 1.0) {\r\n        buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n          buildover_fullstatemach_IN_Kill;\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant13_Value;\r\n        NOT1 = buildover_fullstatemachine_P.Constant1_Value_a;\r\n      } else if (buildover_fullstatemachine_B.Diff == 0.0) {\r\n        buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n          buildover_fullstatemach_IN_VTOL;\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant6_Value_pg;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant3_Value_af;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant5_Value_a;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant4_Value_gr;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant12_Value_e;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant_Value_h;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant1_Value_p;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant2_Value_bd;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant7_Value_e1;\r\n        NOT1 = buildover_fullstatemachine_P.Constant13_Value_l;\r\n      } else {\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant6_Value_cy;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant_Value_as;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant5_Value_n;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant1_Value_g;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant3_Value_j5;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant2_Value_oh;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant4_Value_d;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant11_Value;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant7_Value_j;\r\n        NOT1 = buildover_fullstatemachine_P.Constant13_Value_kn;\r\n      }\r\n      break;\r\n\r\n     case buildover_fullstatemach_IN_VTOL:\r\n      if (buildover_fullstatemachine_B.CastToDouble16 == 1.0) {\r\n        buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n          buildover_fullstatemach_IN_Kill;\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant13_Value;\r\n        NOT1 = buildover_fullstatemachine_P.Constant1_Value_a;\r\n      } else if ((uDLookupTable6 == 2) || (uDLookupTable6 == 6) ||\r\n                 (uDLookupTable6 == 7)) {\r\n        buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n          buildover_IN_Rotor_DEACCEL_prep;\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant4_Value_l;\r\n        buildover_fullstatemachine_B.Switch =\r\n          buildover_fullstatemachine_P.Constant2_Value_i -\r\n          buildover_fullstatemachine_DW.DiscreteTimeIntegrator_DSTATE;\r\n        if (buildover_fullstatemachine_B.Switch >\r\n            buildover_fullstatemachine_P.Saturation6_UpperSat) {\r\n          buildover_fullstatemachine_B.mainrotor_control =\r\n            buildover_fullstatemachine_P.Saturation6_UpperSat;\r\n        } else if (buildover_fullstatemachine_B.Switch <\r\n                   buildover_fullstatemachine_P.Saturation6_LowerSat) {\r\n          buildover_fullstatemachine_B.mainrotor_control =\r\n            buildover_fullstatemachine_P.Saturation6_LowerSat;\r\n        } else {\r\n          buildover_fullstatemachine_B.mainrotor_control =\r\n            buildover_fullstatemachine_B.Switch;\r\n        }\r\n\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant5_Value_f;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant3_Value_p;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant14_Value_ch;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant_Value_a;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant12_Value_p;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant1_Value_k;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant6_Value_f;\r\n        NOT1 = buildover_fullstatemachine_P.Constant13_Value_n;\r\n        buildover_fullstatemachine_DW.DiscreteTimeIntegrator_DSTATE +=\r\n          buildover_fullstatemachine_B.Switch *\r\n          buildover_fullstatemachine_B.Switch *\r\n          buildover_fullstatemachine_P.Constant7_Value_o *\r\n          buildover_fullstatemachine_P.DiscreteTimeIntegrator_gainval;\r\n        if (buildover_fullstatemachine_DW.DiscreteTimeIntegrator_DSTATE >=\r\n            buildover_fullstatemachine_P.DiscreteTimeIntegrator_UpperSat) {\r\n          buildover_fullstatemachine_DW.DiscreteTimeIntegrator_DSTATE =\r\n            buildover_fullstatemachine_P.DiscreteTimeIntegrator_UpperSat;\r\n        } else if (buildover_fullstatemachine_DW.DiscreteTimeIntegrator_DSTATE <=\r\n                   buildover_fullstatemachine_P.DiscreteTimeIntegrator_LowerSat)\r\n        {\r\n          buildover_fullstatemachine_DW.DiscreteTimeIntegrator_DSTATE =\r\n            buildover_fullstatemachine_P.DiscreteTimeIntegrator_LowerSat;\r\n        }\r\n      } else {\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant6_Value_pg;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant3_Value_af;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant5_Value_a;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant4_Value_gr;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant12_Value_e;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant_Value_h;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant1_Value_p;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant2_Value_bd;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant7_Value_e1;\r\n        NOT1 = buildover_fullstatemachine_P.Constant13_Value_l;\r\n      }\r\n      break;\r\n\r\n     case buildover_fullstat_IN_off_armed:\r\n      buildover_fullstatema_off_armed(&NOT1,\r\n        &buildover_fullstatemachine_B.Diff_l,\r\n        &buildover_fullstatemachine_B.Diff_g, &uDLookupTable6,\r\n        &buildover_fullstatemachine_B.w_ff_gain,\r\n        &buildover_fullstatemachine_B.CastToDouble);\r\n      break;\r\n\r\n     default:\r\n      if ((buildover_fullstatemachine_B.CastToDouble == 1.0) && (uDLookupTable6 ==\r\n           1)) {\r\n        buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n          buildover_fullstat_IN_off_armed;\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant2_Value_h;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant2_Value_h;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant3_Value_jc;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant4_Value_e;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant14_Value_f;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant6_Value_f5;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant12_Value_j;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant1_Value_ly;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant11_Value_a;\r\n        NOT1 = buildover_fullstatemachine_P.Constant13_Value_d;\r\n      } else if (buildover_fullstatemachine_B.CastToDouble16 == 1.0) {\r\n        buildover_fullstatemachine_DW.is_c3_buildover_fullstatemachin =\r\n          buildover_fullstatemach_IN_Kill;\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant_Value_fc;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant13_Value;\r\n        NOT1 = buildover_fullstatemachine_P.Constant1_Value_a;\r\n      } else {\r\n        buildover_fullstatemachine_B.w_ff_gain =\r\n          buildover_fullstatemachine_P.Constant12_Value_d;\r\n        buildover_fullstatemachine_B.tau_ff_gain =\r\n          buildover_fullstatemachine_P.Constant1_Value_o;\r\n        buildover_fullstatemachine_B.Diff_l =\r\n          buildover_fullstatemachine_P.Constant11_Value_c;\r\n        buildover_fullstatemachine_B.lcb_speed =\r\n          buildover_fullstatemachine_P.Constant2_Value_o4;\r\n        buildover_fullstatemachine_B.rcb_speed =\r\n          buildover_fullstatemachine_P.Constant2_Value_o4;\r\n        buildover_fullstatemachine_B.mainrotor_control =\r\n          buildover_fullstatemachine_P.Constant3_Value_l;\r\n        buildover_fullstatemachine_B.leftcb_angle =\r\n          buildover_fullstatemachine_P.Constant4_Value_i;\r\n        buildover_fullstatemachine_B.rightcb_angle =\r\n          buildover_fullstatemachine_P.Constant4_Value_i;\r\n        buildover_fullstatemachine_B.Diff_g =\r\n          buildover_fullstatemachine_P.Constant6_Value_b;\r\n        NOT1 = buildover_fullstatemachine_P.Constant13_Value_f;\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (buildover_fullstatemachine_B.mainrotor_control >\r\n      buildover_fullstatemachine_P.Switch_Threshold) {\r\n    buildover_fullstatemachine_B.Switch =\r\n      buildover_fullstatemachine_B.mainrotor_control;\r\n  } else {\r\n    buildover_fullstatemachine_B.Switch = look1_binlxpw\r\n      (-buildover_fullstatemachine_B.Saturation,\r\n       buildover_fullstatemachine_P.uDLookupTable5_bp01Data,\r\n       buildover_fullstatemachine_P.uDLookupTable5_tableData, 1U);\r\n    if (buildover_fullstatemachine_B.Switch >\r\n        buildover_fullstatemachine_P.Saturation5_UpperSat) {\r\n      buildover_fullstatemachine_B.Switch =\r\n        buildover_fullstatemachine_P.Saturation5_UpperSat;\r\n    } else if (buildover_fullstatemachine_B.Switch <\r\n               buildover_fullstatemachine_P.Saturation5_LowerSat) {\r\n      buildover_fullstatemachine_B.Switch =\r\n        buildover_fullstatemachine_P.Saturation5_LowerSat;\r\n    }\r\n  }\r\n\r\n  buildover_fullstatemachine_B.RateLimiter1_f =\r\n    buildover_fullstatemachine_B.leftcb_angle -\r\n    buildover_fullstatemachine_DW.PrevY_l;\r\n  if (buildover_fullstatemachine_B.RateLimiter1_f >\r\n      buildover_fullstatemachine_P.RateLimiter1_RisingLim *\r\n      buildover_fullstatemachi_period) {\r\n    buildover_fullstatemachine_B.RateLimiter1 =\r\n      buildover_fullstatemachine_P.RateLimiter1_RisingLim *\r\n      buildover_fullstatemachi_period + buildover_fullstatemachine_DW.PrevY_l;\r\n  } else if (buildover_fullstatemachine_B.RateLimiter1_f <\r\n             buildover_fullstatemachine_P.RateLimiter1_FallingLim *\r\n             buildover_fullstatemachi_period) {\r\n    buildover_fullstatemachine_B.RateLimiter1 =\r\n      buildover_fullstatemachine_P.RateLimiter1_FallingLim *\r\n      buildover_fullstatemachi_period + buildover_fullstatemachine_DW.PrevY_l;\r\n  } else {\r\n    buildover_fullstatemachine_B.RateLimiter1 =\r\n      buildover_fullstatemachine_B.leftcb_angle;\r\n  }\r\n\r\n  buildover_fullstatemachine_DW.PrevY_l =\r\n    buildover_fullstatemachine_B.RateLimiter1;\r\n  buildover_fullstatemachine_B.RateLimiter1_f =\r\n    buildover_fullstatemachine_B.rightcb_angle -\r\n    buildover_fullstatemachine_DW.PrevY_f;\r\n  if (buildover_fullstatemachine_B.RateLimiter1_f >\r\n      buildover_fullstatemachine_P.RateLimiter1_RisingLim_p *\r\n      buildover_fullstatemachi_period) {\r\n    buildover_fullstatemachine_B.RateLimiter1_f =\r\n      buildover_fullstatemachine_P.RateLimiter1_RisingLim_p *\r\n      buildover_fullstatemachi_period + buildover_fullstatemachine_DW.PrevY_f;\r\n  } else if (buildover_fullstatemachine_B.RateLimiter1_f <\r\n             buildover_fullstatemachine_P.RateLimiter1_FallingLim_k *\r\n             buildover_fullstatemachi_period) {\r\n    buildover_fullstatemachine_B.RateLimiter1_f =\r\n      buildover_fullstatemachine_P.RateLimiter1_FallingLim_k *\r\n      buildover_fullstatemachi_period + buildover_fullstatemachine_DW.PrevY_f;\r\n  } else {\r\n    buildover_fullstatemachine_B.RateLimiter1_f =\r\n      buildover_fullstatemachine_B.rightcb_angle;\r\n  }\r\n\r\n  buildover_fullstatemachine_DW.PrevY_f =\r\n    buildover_fullstatemachine_B.RateLimiter1_f;\r\n  u0_tmp = buildover_fullstatemachine_P.Gain_Gain * fabs\r\n    (buildover_fullstatemachine_B.Diff) *\r\n    buildover_fullstatemachine_B.tau_ff_gain;\r\n  buildover_fullstatemachine_B.Saturation =\r\n    -buildover_fullstatemachine_B.Saturation *\r\n    -buildover_fullstatemachine_B.Saturation;\r\n  buildover_fullstatemachine_B.Diff = look1_binlxpw\r\n    (((buildover_fullstatemachine_P.Gain6_Gain *\r\n       buildover_fullstatemachine_B.rcb_speed +\r\n       buildover_fullstatemachine_P.Constant2_Value_p) + u0_tmp) +\r\n     buildover_fullstatemachine_B.Saturation *\r\n     buildover_fullstatemachine_P.Gain11_Gain *\r\n     buildover_fullstatemachine_B.w_ff_gain,\r\n     buildover_fullstatemachine_P.uDLookupTable4_bp01Data,\r\n     buildover_fullstatemachine_P.uDLookupTable4_tableData, 1U);\r\n  if (buildover_fullstatemachine_B.Diff >\r\n      buildover_fullstatemachine_P.Saturation1_UpperSat) {\r\n    buildover_fullstatemachine_B.Diff =\r\n      buildover_fullstatemachine_P.Saturation1_UpperSat;\r\n  } else if (buildover_fullstatemachine_B.Diff <\r\n             buildover_fullstatemachine_P.Saturation1_LowerSat) {\r\n    buildover_fullstatemachine_B.Diff =\r\n      buildover_fullstatemachine_P.Saturation1_LowerSat;\r\n  }\r\n\r\n  buildover_fullstatemachine_B.Saturation = look1_binlxpw\r\n    (((buildover_fullstatemachine_P.Gain7_Gain *\r\n       buildover_fullstatemachine_B.lcb_speed +\r\n       buildover_fullstatemachine_P.Constant2_Value_l) + u0_tmp) +\r\n     buildover_fullstatemachine_B.Saturation *\r\n     buildover_fullstatemachine_P.Gain11_Gain_j *\r\n     buildover_fullstatemachine_B.w_ff_gain,\r\n     buildover_fullstatemachine_P.uDLookupTable4_bp01Data_k,\r\n     buildover_fullstatemachine_P.uDLookupTable4_tableData_b, 1U);\r\n  if (buildover_fullstatemachine_B.Saturation >\r\n      buildover_fullstatemachine_P.Saturation_UpperSat_a) {\r\n    buildover_fullstatemachine_B.Saturation =\r\n      buildover_fullstatemachine_P.Saturation_UpperSat_a;\r\n  } else if (buildover_fullstatemachine_B.Saturation <\r\n             buildover_fullstatemachine_P.Saturation_LowerSat_j) {\r\n    buildover_fullstatemachine_B.Saturation =\r\n      buildover_fullstatemachine_P.Saturation_LowerSat_j;\r\n  }\r\n\r\n  mask1 = uORB_read_step(buildover_fullstatemachine_DW.obj_m.orbMetadataObj,\r\n    &buildover_fullstatemachine_DW.obj_m.eventStructObj,\r\n    &buildover_fullstatemachine_B.b_varargout_2, false, 1.0);\r\n  if (mask1) {\r\n    buildover_fullstatemachine_B.In1 =\r\n      buildover_fullstatemachine_B.b_varargout_2;\r\n  }\r\n\r\n  zcEvent = rt_ZCFcn(RISING_ZERO_CROSSING,\r\n                     &buildover_fullstatemach_PrevZCX.SampleandHold_Trig_ZCE,\r\n                     (buildover_fullstatemachine_DW.Memory_PreviousInput_g));\r\n  if (zcEvent != NO_ZCEVENT) {\r\n    buildover_fullstatemachine_B.In = buildover_fullstatemachine_B.In1.z;\r\n  }\r\n\r\n  mask1 = uORB_read_step(buildover_fullstatemachine_DW.obj_pt.orbMetadataObj,\r\n    &buildover_fullstatemachine_DW.obj_pt.eventStructObj,\r\n    &buildover_fullstatemachine_B.b_varargout_2_c, false, 1.0);\r\n  if (mask1) {\r\n    buildover_fullstatemachine_B.In1_b =\r\n      buildover_fullstatemachine_B.b_varargout_2_c;\r\n  }\r\n\r\n  buildover_fullstatemachine_B.DataTypeConversion6[0] =\r\n    buildover_fullstatemachine_B.In1_b.q[0];\r\n  x[0] = rtIsNaN(static_cast<real_T>(buildover_fullstatemachine_B.In1_b.q[0]));\r\n  buildover_fullstatemachine_B.DataTypeConversion6[1] =\r\n    buildover_fullstatemachine_B.In1_b.q[1];\r\n  x[1] = rtIsNaN(static_cast<real_T>(buildover_fullstatemachine_B.In1_b.q[1]));\r\n  buildover_fullstatemachine_B.DataTypeConversion6[2] =\r\n    buildover_fullstatemachine_B.In1_b.q[2];\r\n  x[2] = rtIsNaN(static_cast<real_T>(buildover_fullstatemachine_B.In1_b.q[2]));\r\n  buildover_fullstatemachine_B.DataTypeConversion6[3] =\r\n    buildover_fullstatemachine_B.In1_b.q[3];\r\n  x[3] = rtIsNaN(static_cast<real_T>(buildover_fullstatemachine_B.In1_b.q[3]));\r\n  mask1 = false;\r\n  k = 0;\r\n  exitg1 = false;\r\n  while ((!exitg1) && (k < 4)) {\r\n    if (x[k]) {\r\n      mask1 = true;\r\n      exitg1 = true;\r\n    } else {\r\n      k++;\r\n    }\r\n  }\r\n\r\n  if (mask1) {\r\n    buildover_fullstatemachine_B.DataTypeConversion6[0] = 1.0;\r\n    buildover_fullstatemachine_B.DataTypeConversion6[1] = 0.0;\r\n    buildover_fullstatemachine_B.DataTypeConversion6[2] = 0.0;\r\n    buildover_fullstatemachine_B.DataTypeConversion6[3] = 0.0;\r\n  } else {\r\n    buildover_fullstatemachine_B.aSinInput = buildover_fullstatemachine_norm\r\n      (buildover_fullstatemachine_B.DataTypeConversion6);\r\n    if (buildover_fullstatemachine_B.aSinInput < 0.1) {\r\n      buildover_fullstatemachine_B.DataTypeConversion6[0] = 1.0;\r\n      buildover_fullstatemachine_B.DataTypeConversion6[1] = 0.0;\r\n      buildover_fullstatemachine_B.DataTypeConversion6[2] = 0.0;\r\n      buildover_fullstatemachine_B.DataTypeConversion6[3] = 0.0;\r\n    } else {\r\n      buildover_fullstatemachine_B.DataTypeConversion6[0] =\r\n        buildover_fullstatemachine_B.In1_b.q[0] /\r\n        buildover_fullstatemachine_B.aSinInput;\r\n      buildover_fullstatemachine_B.DataTypeConversion6[1] =\r\n        buildover_fullstatemachine_B.In1_b.q[1] /\r\n        buildover_fullstatemachine_B.aSinInput;\r\n      buildover_fullstatemachine_B.DataTypeConversion6[2] =\r\n        buildover_fullstatemachine_B.In1_b.q[2] /\r\n        buildover_fullstatemachine_B.aSinInput;\r\n      buildover_fullstatemachine_B.DataTypeConversion6[3] =\r\n        buildover_fullstatemachine_B.In1_b.q[3] /\r\n        buildover_fullstatemachine_B.aSinInput;\r\n    }\r\n  }\r\n\r\n  buildover_fullstatemachine_B.aSinInput = 1.0 / sqrt\r\n    (((buildover_fullstatemachine_B.DataTypeConversion6[0] *\r\n       buildover_fullstatemachine_B.DataTypeConversion6[0] +\r\n       buildover_fullstatemachine_B.DataTypeConversion6[1] *\r\n       buildover_fullstatemachine_B.DataTypeConversion6[1]) +\r\n      buildover_fullstatemachine_B.DataTypeConversion6[2] *\r\n      buildover_fullstatemachine_B.DataTypeConversion6[2]) +\r\n     buildover_fullstatemachine_B.DataTypeConversion6[3] *\r\n     buildover_fullstatemachine_B.DataTypeConversion6[3]);\r\n  buildover_fullstatemachine_B.w_ff_gain =\r\n    buildover_fullstatemachine_B.DataTypeConversion6[0] *\r\n    buildover_fullstatemachine_B.aSinInput;\r\n  u0_tmp = buildover_fullstatemachine_B.DataTypeConversion6[1] *\r\n    buildover_fullstatemachine_B.aSinInput;\r\n  y_idx_2 = buildover_fullstatemachine_B.DataTypeConversion6[2] *\r\n    buildover_fullstatemachine_B.aSinInput;\r\n  buildover_fullstatemachine_B.y_idx_3 =\r\n    buildover_fullstatemachine_B.DataTypeConversion6[3] *\r\n    buildover_fullstatemachine_B.aSinInput;\r\n  buildover_fullstatemachine_B.aSinInput = (u0_tmp *\r\n    buildover_fullstatemachine_B.y_idx_3 -\r\n    buildover_fullstatemachine_B.w_ff_gain * y_idx_2) * -2.0;\r\n  mask1 = (buildover_fullstatemachine_B.aSinInput >= 0.99999999999999778);\r\n  b_idx_0 = buildover_fullstatemachine_B.aSinInput;\r\n  if (mask1) {\r\n    b_idx_0 = 1.0;\r\n  }\r\n\r\n  if (buildover_fullstatemachine_B.aSinInput <= -0.99999999999999778) {\r\n    b_idx_0 = -1.0;\r\n  }\r\n\r\n  mask1 = (mask1 || (buildover_fullstatemachine_B.aSinInput <=\r\n                     -0.99999999999999778));\r\n  buildover_fullstatemachine_B.aSinInput =\r\n    buildover_fullstatemachine_B.w_ff_gain *\r\n    buildover_fullstatemachine_B.w_ff_gain;\r\n  out_tmp = u0_tmp * u0_tmp;\r\n  out_tmp_0 = y_idx_2 * y_idx_2;\r\n  out_tmp_1 = buildover_fullstatemachine_B.y_idx_3 *\r\n    buildover_fullstatemachine_B.y_idx_3;\r\n  buildover_fullstatemachine_B.out[0] = rt_atan2d_snf((u0_tmp * y_idx_2 +\r\n    buildover_fullstatemachine_B.w_ff_gain *\r\n    buildover_fullstatemachine_B.y_idx_3) * 2.0,\r\n    ((buildover_fullstatemachine_B.aSinInput + out_tmp) - out_tmp_0) - out_tmp_1);\r\n  buildover_fullstatemachine_B.out[1] = asin(b_idx_0);\r\n  buildover_fullstatemachine_B.out[2] = rt_atan2d_snf((y_idx_2 *\r\n    buildover_fullstatemachine_B.y_idx_3 +\r\n    buildover_fullstatemachine_B.w_ff_gain * u0_tmp) * 2.0,\r\n    ((buildover_fullstatemachine_B.aSinInput - out_tmp) - out_tmp_0) + out_tmp_1);\r\n  trueCount = 0;\r\n  if (mask1) {\r\n    for (k = 0; k < 1; k++) {\r\n      trueCount++;\r\n    }\r\n  }\r\n\r\n  f_size_idx_0 = trueCount;\r\n  trueCount = 0;\r\n  if (mask1) {\r\n    for (k = 0; k < 1; k++) {\r\n      trueCount++;\r\n    }\r\n  }\r\n\r\n  g_size_idx_0 = trueCount;\r\n  trueCount = 0;\r\n  if (mask1) {\r\n    for (k = 0; k < 1; k++) {\r\n      trueCount++;\r\n    }\r\n  }\r\n\r\n  h_size_idx_0 = trueCount;\r\n  if (f_size_idx_0 - 1 >= 0) {\r\n    buildover_fullstatemachine_B.b_x_data = b_idx_0;\r\n  }\r\n\r\n  trueCount = f_size_idx_0 - 1;\r\n  for (k = 0; k <= trueCount; k++) {\r\n    if (rtIsNaN(buildover_fullstatemachine_B.b_x_data)) {\r\n      buildover_fullstatemachine_B.b_x_data = (rtNaN);\r\n    } else if (buildover_fullstatemachine_B.b_x_data < 0.0) {\r\n      buildover_fullstatemachine_B.b_x_data = -1.0;\r\n    } else {\r\n      buildover_fullstatemachine_B.b_x_data =\r\n        (buildover_fullstatemachine_B.b_x_data > 0.0);\r\n    }\r\n  }\r\n\r\n  if (g_size_idx_0 == h_size_idx_0) {\r\n    trueCount = g_size_idx_0;\r\n    if (g_size_idx_0 - 1 >= 0) {\r\n      buildover_fullstatemachine_B.j_data = rt_atan2d_snf(u0_tmp,\r\n        buildover_fullstatemachine_B.w_ff_gain);\r\n    }\r\n  } else {\r\n    if (g_size_idx_0 - 1 >= 0) {\r\n      buildover_fullstatemachine_B.y_data = u0_tmp;\r\n    }\r\n\r\n    if (h_size_idx_0 - 1 >= 0) {\r\n      buildover_fullstatemachine_B.y_data_b =\r\n        buildover_fullstatemachine_B.w_ff_gain;\r\n    }\r\n\r\n    buildover_fullstat_expand_atan2(&buildover_fullstatemachine_B.y_data,\r\n      &g_size_idx_0, &buildover_fullstatemachine_B.y_data_b, &h_size_idx_0,\r\n      &buildover_fullstatemachine_B.j_data, &trueCount);\r\n  }\r\n\r\n  if (mask1) {\r\n    for (k = 0; k < 1; k++) {\r\n      tmp_data = 0;\r\n    }\r\n  }\r\n\r\n  if (f_size_idx_0 == trueCount) {\r\n    if (f_size_idx_0 - 1 >= 0) {\r\n      buildover_fullstatemachine_B.out[0] =\r\n        -buildover_fullstatemachine_B.b_x_data * 2.0 *\r\n        buildover_fullstatemachine_B.j_data;\r\n    }\r\n  } else {\r\n    buildover_full_binary_expand_op(buildover_fullstatemachine_B.out, &tmp_data,\r\n      &buildover_fullstatemachine_B.b_x_data, &f_size_idx_0,\r\n      &buildover_fullstatemachine_B.j_data, &trueCount);\r\n  }\r\n\r\n  trueCount = 0;\r\n  if (mask1) {\r\n    for (k = 0; k < 1; k++) {\r\n      trueCount++;\r\n    }\r\n  }\r\n\r\n  if (trueCount - 1 >= 0) {\r\n    buildover_fullstatemachine_B.out[2] = 0.0;\r\n  }\r\n\r\n  mask1 = uORB_read_step(buildover_fullstatemachine_DW.obj_n.orbMetadataObj,\r\n    &buildover_fullstatemachine_DW.obj_n.eventStructObj,\r\n    &buildover_fullstatemachine_B.b_varargout_2_k, false, 1.0);\r\n  if (mask1) {\r\n    buildover_fullstatemachine_B.In1_mg =\r\n      buildover_fullstatemachine_B.b_varargout_2_k;\r\n  }\r\n\r\n  buildover_fullstatemachine_B.BusAssignment.timestamp =\r\n    buildover_fullstatemachine_B.In1_mg.timestamp;\r\n  buildover_fullstatemachine_B.BusAssignment.output[0] = static_cast<real32_T>\r\n    (buildover_fullstatemachine_B.RateLimiter1);\r\n  buildover_fullstatemachine_B.BusAssignment.output[1] = static_cast<real32_T>\r\n    (buildover_fullstatemachine_B.RateLimiter1_f);\r\n  buildover_fullstatemachine_B.BusAssignment.output[2] = static_cast<real32_T>\r\n    (buildover_fullstatemachine_B.Switch);\r\n  buildover_fullstatemachine_B.BusAssignment.output[3] = static_cast<real32_T>\r\n    (buildover_fullstatemachine_B.Saturation);\r\n  buildover_fullstatemachine_B.BusAssignment.output[4] = static_cast<real32_T>\r\n    (buildover_fullstatemachine_B.Diff);\r\n  buildover_fullstatemachine_B.BusAssignment.output[5] = static_cast<real32_T>\r\n    (buildover_fullstatemachine_B.Diff_g);\r\n  buildover_fullstatemachine_B.BusAssignment.output[6] = static_cast<real32_T>\r\n    (buildover_fullstatemachine_B.Diff_l);\r\n  buildover_fullstatemachine_B.BusAssignment.output[7] =\r\n    buildover_fullstatemachine_B.In1.x;\r\n  buildover_fullstatemachine_B.BusAssignment.output[8] =\r\n    buildover_fullstatemachine_B.In1.y;\r\n  buildover_fullstatemachine_B.BusAssignment.output[9] = static_cast<real32_T>\r\n    (buildover_fullstatemachine_B.In1.z - buildover_fullstatemachine_B.In);\r\n  buildover_fullstatemachine_B.BusAssignment.output[10] =\r\n    buildover_fullstatemachine_B.In1.vx;\r\n  buildover_fullstatemachine_B.BusAssignment.output[11] =\r\n    buildover_fullstatemachine_B.In1.vy;\r\n  buildover_fullstatemachine_B.BusAssignment.output[12] =\r\n    buildover_fullstatemachine_B.In1.vz;\r\n  buildover_fullstatemachine_B.BusAssignment.output[13] = static_cast<real32_T>\r\n    (buildover_fullstatemachine_B.out[2]);\r\n  buildover_fullstatemachine_B.BusAssignment.output[14] = static_cast<real32_T>\r\n    (buildover_fullstatemachine_B.out[1]);\r\n  buildover_fullstatemachine_B.BusAssignment.output[15] = static_cast<real32_T>\r\n    (buildover_fullstatemachine_B.out[0]);\r\n  uORB_write_step(buildover_fullstatemachine_DW.obj_g.orbMetadataObj,\r\n                  &buildover_fullstatemachine_DW.obj_g.orbAdvertiseObj,\r\n                  &buildover_fullstatemachine_B.BusAssignment);\r\n  for (k = 0; k < 8; k++) {\r\n    buildover_fullstatemachine_B.pwmValue[k] = 0U;\r\n  }\r\n\r\n  buildover_fullstatemachine_B.Diff_l = floor\r\n    (buildover_fullstatemachine_B.Switch);\r\n  if (rtIsNaN(buildover_fullstatemachine_B.Diff_l) || rtIsInf\r\n      (buildover_fullstatemachine_B.Diff_l)) {\r\n    buildover_fullstatemachine_B.Diff_l = 0.0;\r\n  } else {\r\n    buildover_fullstatemachine_B.Diff_l = fmod\r\n      (buildover_fullstatemachine_B.Diff_l, 65536.0);\r\n  }\r\n\r\n  buildover_fullstatemachine_B.pwmValue[0] = static_cast<uint16_T>\r\n    (buildover_fullstatemachine_B.Diff_l < 0.0 ? static_cast<int32_T>(\r\n      static_cast<uint16_T>(-static_cast<int16_T>(static_cast<uint16_T>\r\n        (-buildover_fullstatemachine_B.Diff_l)))) : static_cast<int32_T>(\r\n      static_cast<uint16_T>(buildover_fullstatemachine_B.Diff_l)));\r\n  buildover_fullstatemachine_B.Diff_l = floor\r\n    (buildover_fullstatemachine_B.RateLimiter1);\r\n  if (rtIsNaN(buildover_fullstatemachine_B.Diff_l) || rtIsInf\r\n      (buildover_fullstatemachine_B.Diff_l)) {\r\n    buildover_fullstatemachine_B.Diff_l = 0.0;\r\n  } else {\r\n    buildover_fullstatemachine_B.Diff_l = fmod\r\n      (buildover_fullstatemachine_B.Diff_l, 65536.0);\r\n  }\r\n\r\n  buildover_fullstatemachine_B.pwmValue[1] = static_cast<uint16_T>\r\n    (buildover_fullstatemachine_B.Diff_l < 0.0 ? static_cast<int32_T>(\r\n      static_cast<uint16_T>(-static_cast<int16_T>(static_cast<uint16_T>\r\n        (-buildover_fullstatemachine_B.Diff_l)))) : static_cast<int32_T>(\r\n      static_cast<uint16_T>(buildover_fullstatemachine_B.Diff_l)));\r\n  buildover_fullstatemachine_B.Diff_l = floor\r\n    (buildover_fullstatemachine_B.RateLimiter1_f);\r\n  if (rtIsNaN(buildover_fullstatemachine_B.Diff_l) || rtIsInf\r\n      (buildover_fullstatemachine_B.Diff_l)) {\r\n    buildover_fullstatemachine_B.Diff_l = 0.0;\r\n  } else {\r\n    buildover_fullstatemachine_B.Diff_l = fmod\r\n      (buildover_fullstatemachine_B.Diff_l, 65536.0);\r\n  }\r\n\r\n  buildover_fullstatemachine_B.pwmValue[2] = static_cast<uint16_T>\r\n    (buildover_fullstatemachine_B.Diff_l < 0.0 ? static_cast<int32_T>(\r\n      static_cast<uint16_T>(-static_cast<int16_T>(static_cast<uint16_T>\r\n        (-buildover_fullstatemachine_B.Diff_l)))) : static_cast<int32_T>(\r\n      static_cast<uint16_T>(buildover_fullstatemachine_B.Diff_l)));\r\n  buildover_fullstatemachine_B.Diff_l = floor(buildover_fullstatemachine_B.Diff);\r\n  if (rtIsNaN(buildover_fullstatemachine_B.Diff_l) || rtIsInf\r\n      (buildover_fullstatemachine_B.Diff_l)) {\r\n    buildover_fullstatemachine_B.Diff_l = 0.0;\r\n  } else {\r\n    buildover_fullstatemachine_B.Diff_l = fmod\r\n      (buildover_fullstatemachine_B.Diff_l, 65536.0);\r\n  }\r\n\r\n  buildover_fullstatemachine_B.pwmValue[3] = static_cast<uint16_T>\r\n    (buildover_fullstatemachine_B.Diff_l < 0.0 ? static_cast<int32_T>(\r\n      static_cast<uint16_T>(-static_cast<int16_T>(static_cast<uint16_T>\r\n        (-buildover_fullstatemachine_B.Diff_l)))) : static_cast<int32_T>(\r\n      static_cast<uint16_T>(buildover_fullstatemachine_B.Diff_l)));\r\n  buildover_fullstatemachine_B.Diff_l = floor\r\n    (buildover_fullstatemachine_B.Saturation);\r\n  if (rtIsNaN(buildover_fullstatemachine_B.Diff_l) || rtIsInf\r\n      (buildover_fullstatemachine_B.Diff_l)) {\r\n    buildover_fullstatemachine_B.Diff_l = 0.0;\r\n  } else {\r\n    buildover_fullstatemachine_B.Diff_l = fmod\r\n      (buildover_fullstatemachine_B.Diff_l, 65536.0);\r\n  }\r\n\r\n  buildover_fullstatemachine_B.pwmValue[4] = static_cast<uint16_T>\r\n    (buildover_fullstatemachine_B.Diff_l < 0.0 ? static_cast<int32_T>(\r\n      static_cast<uint16_T>(-static_cast<int16_T>(static_cast<uint16_T>\r\n        (-buildover_fullstatemachine_B.Diff_l)))) : static_cast<int32_T>(\r\n      static_cast<uint16_T>(buildover_fullstatemachine_B.Diff_l)));\r\n  buildover_fullstatemachine_B.Diff_l = floor\r\n    (buildover_fullstatemachine_B.Diff_g);\r\n  if (rtIsNaN(buildover_fullstatemachine_B.Diff_l) || rtIsInf\r\n      (buildover_fullstatemachine_B.Diff_l)) {\r\n    buildover_fullstatemachine_B.Diff_l = 0.0;\r\n  } else {\r\n    buildover_fullstatemachine_B.Diff_l = fmod\r\n      (buildover_fullstatemachine_B.Diff_l, 65536.0);\r\n  }\r\n\r\n  buildover_fullstatemachine_B.pwmValue[5] = static_cast<uint16_T>\r\n    (buildover_fullstatemachine_B.Diff_l < 0.0 ? static_cast<int32_T>(\r\n      static_cast<uint16_T>(-static_cast<int16_T>(static_cast<uint16_T>\r\n        (-buildover_fullstatemachine_B.Diff_l)))) : static_cast<int32_T>(\r\n      static_cast<uint16_T>(buildover_fullstatemachine_B.Diff_l)));\r\n  if (NOT1) {\r\n    if (!buildover_fullstatemachine_DW.obj.isArmed) {\r\n      buildover_fullstatemachine_DW.obj.isArmed = true;\r\n      uDLookupTable6 = pwm_arm(&buildover_fullstatemachine_DW.obj.pwmDevHandler,\r\n        &buildover_fullstatemachine_DW.obj.armAdvertiseObj);\r\n      buildover_fullstatemachine_DW.obj.errorStatus = static_cast<uint16_T>\r\n        (buildover_fullstatemachine_DW.obj.errorStatus | uDLookupTable6);\r\n    }\r\n\r\n    uDLookupTable6 = pwm_setServo\r\n      (&buildover_fullstatemachine_DW.obj.pwmDevHandler,\r\n       buildover_fullstatemachine_DW.obj.servoCount,\r\n       buildover_fullstatemachine_DW.obj.channelMask,\r\n       &buildover_fullstatemachine_B.pwmValue[0],\r\n       buildover_fullstatemachine_DW.obj.isMain,\r\n       &buildover_fullstatemachine_DW.obj.actuatorAdvertiseObj);\r\n    buildover_fullstatemachine_DW.obj.errorStatus = static_cast<uint16_T>\r\n      (buildover_fullstatemachine_DW.obj.errorStatus | uDLookupTable6);\r\n  } else {\r\n    uDLookupTable6 = pwm_disarm(&buildover_fullstatemachine_DW.obj.pwmDevHandler,\r\n      &buildover_fullstatemachine_DW.obj.armAdvertiseObj);\r\n    buildover_fullstatemachine_DW.obj.errorStatus = static_cast<uint16_T>\r\n      (buildover_fullstatemachine_DW.obj.errorStatus | uDLookupTable6);\r\n    buildover_fullstatemachine_DW.obj.isArmed = false;\r\n    uDLookupTable6 = pwm_resetServo\r\n      (&buildover_fullstatemachine_DW.obj.pwmDevHandler,\r\n       buildover_fullstatemachine_DW.obj.servoCount,\r\n       buildover_fullstatemachine_DW.obj.channelMask,\r\n       buildover_fullstatemachine_DW.obj.isMain,\r\n       &buildover_fullstatemachine_DW.obj.actuatorAdvertiseObj);\r\n    buildover_fullstatemachine_DW.obj.errorStatus = static_cast<uint16_T>\r\n      (buildover_fullstatemachine_DW.obj.errorStatus | uDLookupTable6);\r\n  }\r\n\r\n  if (buildover_fullstatemachine_DW.obj.isMain) {\r\n    uDLookupTable6 = pwm_forceFailsafe\r\n      (&buildover_fullstatemachine_DW.obj.pwmDevHandler, static_cast<int32_T>\r\n       (buildover_fullstatemachine_P.Constant4_Value_n));\r\n    buildover_fullstatemachine_DW.obj.errorStatus = static_cast<uint16_T>\r\n      (buildover_fullstatemachine_DW.obj.errorStatus | uDLookupTable6);\r\n  }\r\n\r\n  rt_ZCFcn(RISING_ZERO_CROSSING,\r\n           &buildover_fullstatemach_PrevZCX.SampleandHold_Trig_ZCE_b,\r\n           (buildover_fullstatemachine_DW.Memory_PreviousInput_h));\r\n  uORB_read_step(buildover_fullstatemachine_DW.obj_p.orbMetadataObj,\r\n                 &buildover_fullstatemachine_DW.obj_p.eventStructObj,\r\n                 &buildover_fullstatemachine_B.b_varargout_2_cx, false, 1.0);\r\n  if (buildover_fullstatemachine_B.mainrotor_control >\r\n      buildover_fullstatemachine_P.Switch1_Threshold) {\r\n    buildover_fullstatemachine_DW.Memory_PreviousInput =\r\n      buildover_fullstatemachine_P.Constant_Value_g;\r\n  } else {\r\n    buildover_fullstatemachine_DW.Memory_PreviousInput =\r\n      buildover_fullstatemachine_B.mainrotor_control;\r\n  }\r\n\r\n  buildover_fullstatemachine_DW.UD_DSTATE = buildover_fullstatemachine_B.TSamp;\r\n  buildover_fullstatemachine_DW.Memory_PreviousInput_d =\r\n    buildover_fullstatemachine_B.RateLimiter1;\r\n  buildover_fullstatemachine_DW.UD_DSTATE_d =\r\n    buildover_fullstatemachine_B.TSamp_o;\r\n  buildover_fullstatemachine_DW.Memory1_PreviousInput =\r\n    buildover_fullstatemachine_B.RateLimiter1_f;\r\n  buildover_fullstatemachine_DW.UD_DSTATE_f =\r\n    buildover_fullstatemachine_B.TSamp_g;\r\n  buildover_fullstatemachine_DW.Memory_PreviousInput_g =\r\n    buildover_fullstatemachine_B.CastToDouble;\r\n  buildover_fullstatemachine_DW.Memory_PreviousInput_h =\r\n    buildover_fullstatemachine_B.CastToDouble;\r\n}\r\n\r\nvoid buildover_fullstatemachine_initialize(void)\r\n{\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n  {\r\n    px4_Bus_actuator_outputs_commanded rtb_BusAssignment;\r\n    buildover_fullstatemach_PrevZCX.SampleandHold_Trig_ZCE_b =\r\n      UNINITIALIZED_ZCSIG;\r\n    buildover_fullstatemach_PrevZCX.SampleandHold_Trig_ZCE = UNINITIALIZED_ZCSIG;\r\n    buildover_fullstatemachine_DW.Memory_PreviousInput =\r\n      buildover_fullstatemachine_P.Memory_InitialCondition;\r\n    buildover_fullstatemachine_DW.PrevY =\r\n      buildover_fullstatemachine_P.RateLimiter_IC;\r\n    buildover_fullstatemachine_DW.UD_DSTATE =\r\n      buildover_fullstatemachine_P.DiscreteDerivative_ICPrevScaled;\r\n    buildover_fullstatemachine_DW.Memory_PreviousInput_d =\r\n      buildover_fullstatemachine_P.Memory_InitialCondition_h;\r\n    buildover_fullstatemachine_DW.UD_DSTATE_d =\r\n      buildover_fullstatemachine_P.DiscreteDerivative_ICPrevScal_b;\r\n    buildover_fullstatemachine_DW.Memory1_PreviousInput =\r\n      buildover_fullstatemachine_P.Memory1_InitialCondition;\r\n    buildover_fullstatemachine_DW.UD_DSTATE_f =\r\n      buildover_fullstatemachine_P.DiscreteDerivative_ICPrevSca_bq;\r\n    buildover_fullstatemachine_DW.PrevY_l =\r\n      buildover_fullstatemachine_P.RateLimiter1_IC;\r\n    buildover_fullstatemachine_DW.PrevY_f =\r\n      buildover_fullstatemachine_P.RateLimiter1_IC_g;\r\n    buildover_fullstatemachine_DW.Memory_PreviousInput_g =\r\n      buildover_fullstatemachine_P.Memory_InitialCondition_hl;\r\n    buildover_fullstatemachine_DW.Memory_PreviousInput_h =\r\n      buildover_fullstatemachine_P.Memory_InitialCondition_p;\r\n    buildover_fullstatemachine_B.In1_m = buildover_fullstatemachine_P.Out1_Y0_a;\r\n    buildover_fullstatemachine_B.In1_n = buildover_fullstatemachine_P.Out1_Y0_d;\r\n    buildover_fullstatemachine_DW.DiscreteTimeIntegrator_DSTATE =\r\n      buildover_fullstatemachine_P.DiscreteTimeIntegrator_IC;\r\n    buildover_fullstatemachine_B.In1 = buildover_fullstatemachine_P.Out1_Y0;\r\n    buildover_fullstatemachine_B.In = buildover_fullstatemachine_P._Y0_g;\r\n    buildover_fullstatemachine_B.In1_b = buildover_fullstatemachine_P.Out1_Y0_l;\r\n    buildover_fullstatemachine_B.In1_mg = buildover_fullstatemachine_P.Out1_Y0_g;\r\n    buildover_fullstatemachine_DW.obj_l.matlabCodegenIsDeleted = false;\r\n    buildover_fullstatemachine_DW.obj_l.isInitialized = 1;\r\n    buildover_fullstatemachine_DW.obj_l.orbMetadataObj = ORB_ID(input_rc);\r\n    uORB_read_initialize(buildover_fullstatemachine_DW.obj_l.orbMetadataObj,\r\n                         &buildover_fullstatemachine_DW.obj_l.eventStructObj);\r\n    buildover_fullstatemachine_DW.obj_l.isSetupComplete = true;\r\n    buildover_fullstatemachine_DW.obj_b.matlabCodegenIsDeleted = false;\r\n    buildover_fullstatemachine_DW.obj_b.isInitialized = 1;\r\n    buildover_fullstatemachine_DW.obj_b.orbMetadataObj = ORB_ID(input_rc);\r\n    uORB_read_initialize(buildover_fullstatemachine_DW.obj_b.orbMetadataObj,\r\n                         &buildover_fullstatemachine_DW.obj_b.eventStructObj);\r\n    buildover_fullstatemachine_DW.obj_b.isSetupComplete = true;\r\n    buildover_fullstatemachine_DW.obj_m.matlabCodegenIsDeleted = false;\r\n    buildover_fullstatemachine_DW.obj_m.isInitialized = 1;\r\n    buildover_fullstatemachine_DW.obj_m.orbMetadataObj = ORB_ID\r\n      (vehicle_local_position);\r\n    uORB_read_initialize(buildover_fullstatemachine_DW.obj_m.orbMetadataObj,\r\n                         &buildover_fullstatemachine_DW.obj_m.eventStructObj);\r\n    buildover_fullstatemachine_DW.obj_m.isSetupComplete = true;\r\n    buildover_fullstatemachine_DW.obj_pt.matlabCodegenIsDeleted = false;\r\n    buildover_fullstatemachine_DW.obj_pt.isInitialized = 1;\r\n    buildover_fullstatemachine_DW.obj_pt.orbMetadataObj = ORB_ID\r\n      (vehicle_attitude);\r\n    uORB_read_initialize(buildover_fullstatemachine_DW.obj_pt.orbMetadataObj,\r\n                         &buildover_fullstatemachine_DW.obj_pt.eventStructObj);\r\n    buildover_fullstatemachine_DW.obj_pt.isSetupComplete = true;\r\n    buildover_fullstatemachine_DW.obj_n.matlabCodegenIsDeleted = false;\r\n    buildover_fullstatemachine_DW.obj_n.isInitialized = 1;\r\n    buildover_fullstatemachine_DW.obj_n.orbMetadataObj = ORB_ID\r\n      (vehicle_angular_velocity);\r\n    uORB_read_initialize(buildover_fullstatemachine_DW.obj_n.orbMetadataObj,\r\n                         &buildover_fullstatemachine_DW.obj_n.eventStructObj);\r\n    buildover_fullstatemachine_DW.obj_n.isSetupComplete = true;\r\n    buildover_fullstatemachine_DW.obj_g.matlabCodegenIsDeleted = false;\r\n    buildover_fullstatemachine_DW.obj_g.isInitialized = 1;\r\n    buildover_fullstatemachine_DW.obj_g.orbMetadataObj = ORB_ID\r\n      (actuator_outputs_commanded);\r\n    uORB_write_initialize(buildover_fullstatemachine_DW.obj_g.orbMetadataObj,\r\n                          &buildover_fullstatemachine_DW.obj_g.orbAdvertiseObj,\r\n                          &rtb_BusAssignment, 1);\r\n    buildover_fullstatemachine_DW.obj_g.isSetupComplete = true;\r\n    buildover_fullstatemachine_DW.obj.errorStatus = 0U;\r\n    buildover_fullstatemachine_DW.obj.isInitialized = 0;\r\n    buildover_fullstatemachine_DW.obj.matlabCodegenIsDeleted = false;\r\n    buildover_full_SystemCore_setup(&buildover_fullstatemachine_DW.obj, false,\r\n      buildover_fullstatemachine_P.Constant4_Value_n);\r\n    buildover_fullstatemachine_DW.obj_p.matlabCodegenIsDeleted = false;\r\n    buildover_fullstatemachine_DW.obj_p.isInitialized = 1;\r\n    buildover_fullstatemachine_DW.obj_p.orbMetadataObj = ORB_ID(airspeed);\r\n    uORB_read_initialize(buildover_fullstatemachine_DW.obj_p.orbMetadataObj,\r\n                         &buildover_fullstatemachine_DW.obj_p.eventStructObj);\r\n    buildover_fullstatemachine_DW.obj_p.isSetupComplete = true;\r\n  }\r\n}\r\n\r\nvoid buildover_fullstatemachine_terminate(void)\r\n{\r\n  if (!buildover_fullstatemachine_DW.obj_l.matlabCodegenIsDeleted) {\r\n    buildover_fullstatemachine_DW.obj_l.matlabCodegenIsDeleted = true;\r\n    if ((buildover_fullstatemachine_DW.obj_l.isInitialized == 1) &&\r\n        buildover_fullstatemachine_DW.obj_l.isSetupComplete) {\r\n      uORB_read_terminate(&buildover_fullstatemachine_DW.obj_l.eventStructObj);\r\n    }\r\n  }\r\n\r\n  if (!buildover_fullstatemachine_DW.obj_b.matlabCodegenIsDeleted) {\r\n    buildover_fullstatemachine_DW.obj_b.matlabCodegenIsDeleted = true;\r\n    if ((buildover_fullstatemachine_DW.obj_b.isInitialized == 1) &&\r\n        buildover_fullstatemachine_DW.obj_b.isSetupComplete) {\r\n      uORB_read_terminate(&buildover_fullstatemachine_DW.obj_b.eventStructObj);\r\n    }\r\n  }\r\n\r\n  if (!buildover_fullstatemachine_DW.obj_m.matlabCodegenIsDeleted) {\r\n    buildover_fullstatemachine_DW.obj_m.matlabCodegenIsDeleted = true;\r\n    if ((buildover_fullstatemachine_DW.obj_m.isInitialized == 1) &&\r\n        buildover_fullstatemachine_DW.obj_m.isSetupComplete) {\r\n      uORB_read_terminate(&buildover_fullstatemachine_DW.obj_m.eventStructObj);\r\n    }\r\n  }\r\n\r\n  if (!buildover_fullstatemachine_DW.obj_pt.matlabCodegenIsDeleted) {\r\n    buildover_fullstatemachine_DW.obj_pt.matlabCodegenIsDeleted = true;\r\n    if ((buildover_fullstatemachine_DW.obj_pt.isInitialized == 1) &&\r\n        buildover_fullstatemachine_DW.obj_pt.isSetupComplete) {\r\n      uORB_read_terminate(&buildover_fullstatemachine_DW.obj_pt.eventStructObj);\r\n    }\r\n  }\r\n\r\n  if (!buildover_fullstatemachine_DW.obj_n.matlabCodegenIsDeleted) {\r\n    buildover_fullstatemachine_DW.obj_n.matlabCodegenIsDeleted = true;\r\n    if ((buildover_fullstatemachine_DW.obj_n.isInitialized == 1) &&\r\n        buildover_fullstatemachine_DW.obj_n.isSetupComplete) {\r\n      uORB_read_terminate(&buildover_fullstatemachine_DW.obj_n.eventStructObj);\r\n    }\r\n  }\r\n\r\n  if (!buildover_fullstatemachine_DW.obj_g.matlabCodegenIsDeleted) {\r\n    buildover_fullstatemachine_DW.obj_g.matlabCodegenIsDeleted = true;\r\n    if ((buildover_fullstatemachine_DW.obj_g.isInitialized == 1) &&\r\n        buildover_fullstatemachine_DW.obj_g.isSetupComplete) {\r\n      uORB_write_terminate(&buildover_fullstatemachine_DW.obj_g.orbAdvertiseObj);\r\n    }\r\n  }\r\n\r\n  if (!buildover_fullstatemachine_DW.obj.matlabCodegenIsDeleted) {\r\n    buildover_fullstatemachine_DW.obj.matlabCodegenIsDeleted = true;\r\n    if ((buildover_fullstatemachine_DW.obj.isInitialized == 1) &&\r\n        buildover_fullstatemachine_DW.obj.isSetupComplete) {\r\n      uint16_T status;\r\n      status = pwm_disarm(&buildover_fullstatemachine_DW.obj.pwmDevHandler,\r\n                          &buildover_fullstatemachine_DW.obj.armAdvertiseObj);\r\n      buildover_fullstatemachine_DW.obj.errorStatus = static_cast<uint16_T>\r\n        (buildover_fullstatemachine_DW.obj.errorStatus | status);\r\n      status = pwm_resetServo(&buildover_fullstatemachine_DW.obj.pwmDevHandler,\r\n        buildover_fullstatemachine_DW.obj.servoCount,\r\n        buildover_fullstatemachine_DW.obj.channelMask,\r\n        buildover_fullstatemachine_DW.obj.isMain,\r\n        &buildover_fullstatemachine_DW.obj.actuatorAdvertiseObj);\r\n      buildover_fullstatemachine_DW.obj.errorStatus = static_cast<uint16_T>\r\n        (buildover_fullstatemachine_DW.obj.errorStatus | status);\r\n      status = pwm_close(&buildover_fullstatemachine_DW.obj.pwmDevHandler,\r\n                         &buildover_fullstatemachine_DW.obj.actuatorAdvertiseObj,\r\n                         &buildover_fullstatemachine_DW.obj.armAdvertiseObj);\r\n      buildover_fullstatemachine_DW.obj.errorStatus = static_cast<uint16_T>\r\n        (buildover_fullstatemachine_DW.obj.errorStatus | status);\r\n    }\r\n  }\r\n\r\n  if (!buildover_fullstatemachine_DW.obj_p.matlabCodegenIsDeleted) {\r\n    buildover_fullstatemachine_DW.obj_p.matlabCodegenIsDeleted = true;\r\n    if ((buildover_fullstatemachine_DW.obj_p.isInitialized == 1) &&\r\n        buildover_fullstatemachine_DW.obj_p.isSetupComplete) {\r\n      uORB_read_terminate(&buildover_fullstatemachine_DW.obj_p.eventStructObj);\r\n    }\r\n  }\r\n}\r\n"},{"name":"buildover_fullstatemachine.h","type":"header","group":"model","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Model files","code":"#ifndef RTW_HEADER_buildover_fullstatemachine_h_\r\n#define RTW_HEADER_buildover_fullstatemachine_h_\r\n#include <poll.h>\r\n#include <uORB/uORB.h>\r\n#include \"rtwtypes.h\"\r\n#include \"MW_PX4_PWM.h\"\r\n#include \"MW_uORB_Write.h\"\r\n#include \"MW_uORB_Read.h\"\r\n#include \"buildover_fullstatemachine_types.h\"\r\n#include <uORB/topics/vehicle_local_position.h>\r\n#include <uORB/topics/actuator_outputs_commanded.h>\r\n#include <uORB/topics/input_rc.h>\r\n#include <uORB/topics/vehicle_attitude.h>\r\n#include <uORB/topics/vehicle_angular_velocity.h>\r\n#include <uORB/topics/airspeed.h>\r\n#include \"rt_zcfcn.h\"\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rtGetNaN.h\"\r\n\r\n}\r\n\r\n#include <stddef.h>\r\n#include \"zero_crossing_types.h\"\r\n\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\nstruct B_buildover_fullstatemachine_T {\r\n  px4_Bus_vehicle_local_position In1;\r\n  px4_Bus_vehicle_local_position b_varargout_2;\r\n  px4_Bus_actuator_outputs_commanded BusAssignment;\r\n  px4_Bus_input_rc In1_n;\r\n  px4_Bus_input_rc In1_m;\r\n  px4_Bus_input_rc b_varargout_2_m;\r\n  px4_Bus_vehicle_attitude In1_b;\r\n  px4_Bus_vehicle_attitude b_varargout_2_c;\r\n  px4_Bus_vehicle_angular_velocity In1_mg;\r\n  px4_Bus_vehicle_angular_velocity b_varargout_2_k;\r\n  real_T DataTypeConversion6[4];\r\n  px4_Bus_airspeed b_varargout_2_cx;\r\n  real_T out[3];\r\n  uint16_T pwmValue[8];\r\n  real_T CastToDouble16;\r\n  real_T In;\r\n  real_T tau_ff_gain;\r\n  real_T lcb_speed;\r\n  real_T mainrotor_control;\r\n  real_T rcb_speed;\r\n  real_T rightcb_angle;\r\n  real_T leftcb_angle;\r\n  real_T aSinInput;\r\n  real_T j_data;\r\n  real_T b_x_data;\r\n  real_T Saturation;\r\n  real_T TSamp;\r\n  real_T Switch;\r\n  real_T TSamp_o;\r\n  real_T TSamp_g;\r\n  real_T RateLimiter1;\r\n  real_T RateLimiter1_f;\r\n  real_T Diff_g;\r\n  real_T Diff_l;\r\n  real_T y_data;\r\n  real_T y_data_b;\r\n  real_T Diff;\r\n  real_T w_ff_gain;\r\n  real_T CastToDouble;\r\n  real_T y_idx_3;\r\n};\r\n\r\nstruct DW_buildover_fullstatemachine_T {\r\n  px4_internal_block_PWM_buildo_T obj;\r\n  px4_internal_block_Subscriber_T obj_b;\r\n  px4_internal_block_Subscriber_T obj_p;\r\n  px4_internal_block_Subscriber_T obj_n;\r\n  px4_internal_block_Subscriber_T obj_m;\r\n  px4_internal_block_Subscriber_T obj_pt;\r\n  px4_internal_block_Subscriber_T obj_l;\r\n  px4_internal_block_Publisher__T obj_g;\r\n  real_T UD_DSTATE;\r\n  real_T UD_DSTATE_d;\r\n  real_T UD_DSTATE_f;\r\n  real_T DiscreteTimeIntegrator_DSTATE;\r\n  real_T Memory_PreviousInput;\r\n  real_T PrevY;\r\n  real_T Memory_PreviousInput_d;\r\n  real_T Memory1_PreviousInput;\r\n  real_T PrevY_l;\r\n  real_T PrevY_f;\r\n  real_T Memory_PreviousInput_g;\r\n  real_T Memory_PreviousInput_h;\r\n  uint8_T is_active_c3_buildover_fullstat;\r\n  uint8_T is_c3_buildover_fullstatemachin;\r\n};\r\n\r\nstruct PrevZCX_buildover_fullstatema_T {\r\n  ZCSigState SampleandHold_Trig_ZCE;\r\n  ZCSigState SampleandHold_Trig_ZCE_b;\r\n};\r\n\r\nstruct P_buildover_fullstatemachine_T_ {\r\n  real_T DiscreteDerivative_ICPrevScaled;\r\n  real_T DiscreteDerivative_ICPrevScal_b;\r\n  real_T DiscreteDerivative_ICPrevSca_bq;\r\n  uint16_T WrapToZero1_Threshold;\r\n  uint16_T WrapToZero_Threshold;\r\n  uint16_T WrapToZero1_Threshold_j;\r\n  px4_Bus_vehicle_local_position Out1_Y0;\r\n  px4_Bus_vehicle_local_position Constant_Value;\r\n  px4_Bus_actuator_outputs_commanded Constant_Value_m;\r\n  px4_Bus_input_rc Out1_Y0_a;\r\n  px4_Bus_input_rc Out1_Y0_d;\r\n  px4_Bus_input_rc Constant_Value_p;\r\n  px4_Bus_input_rc Constant_Value_pf;\r\n  px4_Bus_vehicle_attitude Out1_Y0_l;\r\n  px4_Bus_vehicle_attitude Constant_Value_mf;\r\n  px4_Bus_vehicle_angular_velocity Out1_Y0_g;\r\n  px4_Bus_vehicle_angular_velocity Constant_Value_mi;\r\n  px4_Bus_airspeed Out1_Y0_c;\r\n  px4_Bus_airspeed Constant_Value_f;\r\n  real_T Constant_Value_e;\r\n  real_T Constant4_Value;\r\n  real_T Constant3_Value;\r\n  real_T Constant5_Value;\r\n  real_T Constant1_Value;\r\n  real_T Constant9_Value;\r\n  real_T Constant6_Value;\r\n  real_T Constant7_Value;\r\n  real_T Constant8_Value;\r\n  real_T uDLookupTable1_tableData[2];\r\n  real_T uDLookupTable1_bp01Data[2];\r\n  real_T Constant3_Value_a;\r\n  real_T Constant9_Value_e;\r\n  real_T Constant10_Value;\r\n  real_T Constant4_Value_m;\r\n  real_T Constant12_Value;\r\n  real_T Constant2_Value;\r\n  real_T Constant1_Value_d;\r\n  real_T Constant_Value_fc;\r\n  real_T Constant13_Value;\r\n  real_T Constant3_Value_j;\r\n  real_T Constant4_Value_g;\r\n  real_T Constant5_Value_p;\r\n  real_T Constant1_Value_dz;\r\n  real_T Constant14_Value;\r\n  real_T Constant7_Value_e;\r\n  real_T Constant2_Value_b;\r\n  real_T Constant6_Value_p;\r\n  real_T Constant8_Value_c;\r\n  real_T Constant6_Value_pc;\r\n  real_T Constant4_Value_mr;\r\n  real_T Constant5_Value_j;\r\n  real_T Constant3_Value_g;\r\n  real_T Constant14_Value_c;\r\n  real_T Constant_Value_fp;\r\n  real_T Constant1_Value_l;\r\n  real_T Constant2_Value_j;\r\n  real_T Constant7_Value_l;\r\n  real_T Constant6_Value_c;\r\n  real_T Constant5_Value_l;\r\n  real_T Constant4_Value_o;\r\n  real_T Constant3_Value_e;\r\n  real_T Constant14_Value_i;\r\n  real_T Constant_Value_ml;\r\n  real_T Constant1_Value_n;\r\n  real_T Constant2_Value_o;\r\n  real_T Constant7_Value_p;\r\n  real_T Constant4_Value_l;\r\n  real_T Constant2_Value_i;\r\n  real_T DiscreteTimeIntegrator_gainval;\r\n  real_T DiscreteTimeIntegrator_IC;\r\n  real_T DiscreteTimeIntegrator_UpperSat;\r\n  real_T DiscreteTimeIntegrator_LowerSat;\r\n  real_T Constant7_Value_o;\r\n  real_T Saturation6_UpperSat;\r\n  real_T Saturation6_LowerSat;\r\n  real_T Constant5_Value_f;\r\n  real_T Constant3_Value_p;\r\n  real_T Constant14_Value_ch;\r\n  real_T Constant_Value_a;\r\n  real_T Constant12_Value_p;\r\n  real_T Constant1_Value_k;\r\n  real_T Constant6_Value_f;\r\n  real_T Constant6_Value_cy;\r\n  real_T Constant_Value_as;\r\n  real_T Constant5_Value_n;\r\n  real_T Constant1_Value_g;\r\n  real_T Constant3_Value_j5;\r\n  real_T Constant2_Value_oh;\r\n  real_T Constant4_Value_d;\r\n  real_T Constant11_Value;\r\n  real_T Constant7_Value_j;\r\n  real_T Constant6_Value_pg;\r\n  real_T Constant3_Value_af;\r\n  real_T Constant5_Value_a;\r\n  real_T Constant4_Value_gr;\r\n  real_T Constant12_Value_e;\r\n  real_T Constant_Value_h;\r\n  real_T Constant1_Value_p;\r\n  real_T Constant2_Value_bd;\r\n  real_T Constant7_Value_e1;\r\n  real_T Constant2_Value_h;\r\n  real_T Constant3_Value_jc;\r\n  real_T Constant4_Value_e;\r\n  real_T Constant14_Value_f;\r\n  real_T Constant6_Value_f5;\r\n  real_T Constant12_Value_j;\r\n  real_T Constant1_Value_ly;\r\n  real_T Constant11_Value_a;\r\n  real_T Constant12_Value_d;\r\n  real_T Constant1_Value_o;\r\n  real_T Constant11_Value_c;\r\n  real_T Constant2_Value_o4;\r\n  real_T Constant3_Value_l;\r\n  real_T Constant4_Value_i;\r\n  real_T Constant6_Value_b;\r\n  real_T Constant_Value_g;\r\n  real_T uDLookupTable5_tableData[2];\r\n  real_T uDLookupTable5_bp01Data[2];\r\n  real_T Saturation5_UpperSat;\r\n  real_T Saturation5_LowerSat;\r\n  real_T Constant_Value_c;\r\n  real_T Constant_Value_d;\r\n  real_T _Y0;\r\n  real_T _Y0_g;\r\n  real_T Memory_InitialCondition;\r\n  real_T Saturation7_UpperSat;\r\n  real_T Saturation7_LowerSat;\r\n  real_T RateLimiter_RisingLim;\r\n  real_T RateLimiter_FallingLim;\r\n  real_T RateLimiter_IC;\r\n  real_T TSamp_WtEt;\r\n  real_T Memory_InitialCondition_h;\r\n  real_T TSamp_WtEt_m;\r\n  real_T Memory1_InitialCondition;\r\n  real_T TSamp_WtEt_e;\r\n  real_T uDLookupTable1_tableData_b[2];\r\n  real_T uDLookupTable1_bp01Data_g[2];\r\n  real_T Saturation_UpperSat;\r\n  real_T Saturation_LowerSat;\r\n  real_T DeadZone_Start;\r\n  real_T DeadZone_End;\r\n  real_T Switch_Threshold;\r\n  real_T RateLimiter1_RisingLim;\r\n  real_T RateLimiter1_FallingLim;\r\n  real_T RateLimiter1_IC;\r\n  real_T RateLimiter1_RisingLim_p;\r\n  real_T RateLimiter1_FallingLim_k;\r\n  real_T RateLimiter1_IC_g;\r\n  real_T Constant2_Value_p;\r\n  real_T Gain6_Gain;\r\n  real_T Gain_Gain;\r\n  real_T Gain11_Gain;\r\n  real_T uDLookupTable4_tableData[2];\r\n  real_T uDLookupTable4_bp01Data[2];\r\n  real_T Saturation1_UpperSat;\r\n  real_T Saturation1_LowerSat;\r\n  real_T Constant2_Value_l;\r\n  real_T Gain7_Gain;\r\n  real_T Gain11_Gain_j;\r\n  real_T uDLookupTable4_tableData_b[2];\r\n  real_T uDLookupTable4_bp01Data_k[2];\r\n  real_T Saturation_UpperSat_a;\r\n  real_T Saturation_LowerSat_j;\r\n  real_T Memory_InitialCondition_hl;\r\n  real_T Switch1_Threshold;\r\n  real_T Memory_InitialCondition_p;\r\n  uint16_T Constant_Value_p1;\r\n  uint16_T Constant_Value_k;\r\n  uint16_T Constant_Value_j;\r\n  uint16_T uDLookupTable6_tableData[7];\r\n  uint16_T uDLookupTable6_bp01Data[7];\r\n  boolean_T Constant13_Value_j;\r\n  boolean_T Constant13_Value_k;\r\n  boolean_T Constant1_Value_a;\r\n  boolean_T Constant13_Value_p;\r\n  boolean_T Constant13_Value_a;\r\n  boolean_T Constant13_Value_o;\r\n  boolean_T Constant13_Value_n;\r\n  boolean_T Constant13_Value_kn;\r\n  boolean_T Constant13_Value_l;\r\n  boolean_T Constant13_Value_d;\r\n  boolean_T Constant13_Value_f;\r\n  boolean_T Constant4_Value_n;\r\n};\r\n\r\nstruct tag_RTM_buildover_fullstatema_T {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern P_buildover_fullstatemachine_T buildover_fullstatemachine_P;\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern struct B_buildover_fullstatemachine_T buildover_fullstatemachine_B;\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n#endif\r\n\r\nextern struct DW_buildover_fullstatemachine_T buildover_fullstatemachine_DW;\r\nextern PrevZCX_buildover_fullstatema_T buildover_fullstatemach_PrevZCX;\r\n\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern void buildover_fullstatemachine_initialize(void);\r\n  extern void buildover_fullstatemachine_step(void);\r\n  extern void buildover_fullstatemachine_terminate(void);\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern RT_MODEL_buildover_fullstatem_T *const buildover_fullstatemachine_M;\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n#endif\r\n\r\nextern volatile boolean_T stopRequested;\r\nextern volatile boolean_T runModel;\r\n\r\n#endif\r\n\r\n"},{"name":"buildover_fullstatemachine_private.h","type":"header","group":"model","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Model files","code":"#ifndef RTW_HEADER_buildover_fullstatemachine_private_h_\r\n#define RTW_HEADER_buildover_fullstatemachine_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"zero_crossing_types.h\"\r\n#include \"buildover_fullstatemachine_types.h\"\r\n#include \"buildover_fullstatemachine.h\"\r\n#ifndef UCHAR_MAX\r\n#include <limits.h>\r\n#endif\r\n\r\n#if ( UCHAR_MAX != (0xFFU) ) || ( SCHAR_MAX != (0x7F) )\r\n#error Code was generated for compiler with different sized uchar/char. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized ushort/short. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( UINT_MAX != (0xFFFFFFFFU) ) || ( INT_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized uint/int. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( ULONG_MAX != (0xFFFFFFFFU) ) || ( LONG_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized ulong/long. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\nextern real_T rt_atan2d_snf(real_T u0, real_T u1);\r\nextern real_T look1_binlxpw(real_T u0, const real_T bp0[], const real_T table[],\r\n  uint32_T maxIndex);\r\nextern uint32_T plook_u32u16_bincka(uint16_T u, const uint16_T bp[], uint32_T\r\n  maxIndex);\r\nextern uint32_T binsearch_u32u16(uint16_T u, const uint16_T bp[], uint32_T\r\n  startIndex, uint32_T maxIndex);\r\n\r\n#endif\r\n\r\n"},{"name":"buildover_fullstatemachine_types.h","type":"header","group":"model","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Model files","code":"#ifndef RTW_HEADER_buildover_fullstatemachine_types_h_\r\n#define RTW_HEADER_buildover_fullstatemachine_types_h_\r\n#include \"rtwtypes.h\"\r\n#include <uORB/topics/actuator_outputs_commanded.h>\r\n#include <uORB/topics/input_rc.h>\r\n#include <uORB/topics/vehicle_attitude.h>\r\n#include <uORB/topics/vehicle_local_position.h>\r\n#include <uORB/topics/vehicle_angular_velocity.h>\r\n#include <uORB/topics/airspeed.h>\r\n#ifndef struct_px4_internal_block_PWM_buildo_T\r\n#define struct_px4_internal_block_PWM_buildo_T\r\n\r\nstruct px4_internal_block_PWM_buildo_T\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  int pwmDevHandler;\r\n  const char * pwmDevObj;\r\n  unsigned int servoCount;\r\n  int channelMask;\r\n  boolean_T isMain;\r\n  uint16_T errorStatus;\r\n  orb_advert_t armAdvertiseObj;\r\n  orb_advert_t actuatorAdvertiseObj;\r\n  boolean_T isArmed;\r\n};\r\n\r\n#endif\r\n\r\n#ifndef struct_px4_internal_block_Publisher__T\r\n#define struct_px4_internal_block_Publisher__T\r\n\r\nstruct px4_internal_block_Publisher__T\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  orb_advert_t orbAdvertiseObj;\r\n  orb_metadata_t * orbMetadataObj;\r\n};\r\n\r\n#endif\r\n\r\n#ifndef struct_e_px4_internal_block_SampleTi_T\r\n#define struct_e_px4_internal_block_SampleTi_T\r\n\r\nstruct e_px4_internal_block_SampleTi_T\r\n{\r\n  int32_T __dummy;\r\n};\r\n\r\n#endif\r\n\r\n#ifndef struct_px4_internal_block_Subscriber_T\r\n#define struct_px4_internal_block_Subscriber_T\r\n\r\nstruct px4_internal_block_Subscriber_T\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  e_px4_internal_block_SampleTi_T SampleTimeHandler;\r\n  pollfd_t eventStructObj;\r\n  orb_metadata_t * orbMetadataObj;\r\n};\r\n\r\n#endif\r\n\r\n#ifndef struct_robotics_slcore_internal_bloc_T\r\n#define struct_robotics_slcore_internal_bloc_T\r\n\r\nstruct robotics_slcore_internal_bloc_T\r\n{\r\n  int32_T isInitialized;\r\n};\r\n\r\n#endif\r\n\r\ntypedef struct P_buildover_fullstatemachine_T_ P_buildover_fullstatemachine_T;\r\ntypedef struct tag_RTM_buildover_fullstatema_T RT_MODEL_buildover_fullstatem_T;\r\n\r\n#endif\r\n\r\n"},{"name":"buildover_fullstatemachine_data.cpp","type":"source","group":"data","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Data files","code":"#include \"buildover_fullstatemachine.h\"\r\n\r\nP_buildover_fullstatemachine_T buildover_fullstatemachine_P = {\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  1500U,\r\n\r\n  1500U,\r\n\r\n  1500U,\r\n\r\n\r\n  {\r\n    (0ULL),\r\n    (0ULL),\r\n    (0ULL),\r\n    0.0,\r\n    0.0,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n\r\n    {\r\n      0.0F, 0.0F }\r\n    ,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n\r\n    {\r\n      0.0F, 0.0F }\r\n    ,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    false,\r\n    false,\r\n    false,\r\n    false,\r\n    0U,\r\n    0U,\r\n    0U,\r\n    0U,\r\n    0U,\r\n    false,\r\n    false,\r\n    false,\r\n    0U,\r\n\r\n    {\r\n      0U, 0U, 0U }\r\n\r\n  },\r\n\r\n\r\n  {\r\n    (0ULL),\r\n    (0ULL),\r\n    (0ULL),\r\n    0.0,\r\n    0.0,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n\r\n    {\r\n      0.0F, 0.0F }\r\n    ,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n\r\n    {\r\n      0.0F, 0.0F }\r\n    ,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    false,\r\n    false,\r\n    false,\r\n    false,\r\n    0U,\r\n    0U,\r\n    0U,\r\n    0U,\r\n    0U,\r\n    false,\r\n    false,\r\n    false,\r\n    0U,\r\n\r\n    {\r\n      0U, 0U, 0U }\r\n\r\n  },\r\n\r\n\r\n  {\r\n    (0ULL),\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,\r\n      0.0F, 0.0F, 0.0F, 0.0F }\r\n\r\n  },\r\n\r\n\r\n  {\r\n    (0ULL),\r\n    (0ULL),\r\n    0,\r\n    0U,\r\n    0U,\r\n    0U,\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U }\r\n    ,\r\n    0U,\r\n    false,\r\n    false,\r\n    0U,\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U }\r\n\r\n  },\r\n\r\n\r\n  {\r\n    (0ULL),\r\n    (0ULL),\r\n    0,\r\n    0U,\r\n    0U,\r\n    0U,\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U }\r\n    ,\r\n    0U,\r\n    false,\r\n    false,\r\n    0U,\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U }\r\n\r\n  },\r\n\r\n\r\n  {\r\n    (0ULL),\r\n    (0ULL),\r\n    0,\r\n    0U,\r\n    0U,\r\n    0U,\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U }\r\n    ,\r\n    0U,\r\n    false,\r\n    false,\r\n    0U,\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U }\r\n\r\n  },\r\n\r\n\r\n  {\r\n    (0ULL),\r\n    (0ULL),\r\n    0,\r\n    0U,\r\n    0U,\r\n    0U,\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U }\r\n    ,\r\n    0U,\r\n    false,\r\n    false,\r\n    0U,\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U }\r\n\r\n  },\r\n\r\n\r\n  {\r\n    (0ULL),\r\n    (0ULL),\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F, 0.0F }\r\n    ,\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F, 0.0F }\r\n    ,\r\n    0U,\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U }\r\n\r\n  },\r\n\r\n\r\n  {\r\n    (0ULL),\r\n    (0ULL),\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F, 0.0F }\r\n    ,\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F, 0.0F }\r\n    ,\r\n    0U,\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U }\r\n\r\n  },\r\n\r\n\r\n  {\r\n    (0ULL),\r\n    (0ULL),\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F }\r\n    ,\r\n\r\n    {\r\n      0U, 0U, 0U, 0U }\r\n\r\n  },\r\n\r\n\r\n  {\r\n    (0ULL),\r\n    (0ULL),\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F }\r\n    ,\r\n\r\n    {\r\n      0U, 0U, 0U, 0U }\r\n\r\n  },\r\n\r\n\r\n  {\r\n    (0ULL),\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F\r\n  },\r\n\r\n\r\n  {\r\n    (0ULL),\r\n    0.0F,\r\n    0.0F,\r\n    0.0F,\r\n    0.0F\r\n  },\r\n\r\n  0.0,\r\n\r\n  900.0,\r\n\r\n  0.0,\r\n\r\n  575.0,\r\n\r\n  2425.0,\r\n\r\n  1500.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  8.0,\r\n\r\n\r\n  { -0.5, 0.5 },\r\n\r\n\r\n  { -5.0, 5.0 },\r\n\r\n  900.0,\r\n\r\n  575.0,\r\n\r\n  2425.0,\r\n\r\n  1500.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  9.0,\r\n\r\n  0.0,\r\n\r\n  10.0,\r\n\r\n  0.0,\r\n\r\n  900.0,\r\n\r\n  0.0,\r\n\r\n  1520.0,\r\n\r\n  1600.0,\r\n\r\n  1050.0,\r\n\r\n  0.0,\r\n\r\n  1.0,\r\n\r\n  7.0,\r\n\r\n  0.0,\r\n\r\n  -80.0,\r\n\r\n  0.0,\r\n\r\n  575.0,\r\n\r\n  575.0,\r\n\r\n  1050.0,\r\n\r\n  1.0,\r\n\r\n  1.0,\r\n\r\n  6.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  2425.0,\r\n\r\n  2425.0,\r\n\r\n  1050.0,\r\n\r\n  -1.0,\r\n\r\n  1.0,\r\n\r\n  5.0,\r\n\r\n  0.0,\r\n\r\n  -80.0,\r\n\r\n  0.001,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  -12.0,\r\n\r\n  -0.00016684446266502855,\r\n\r\n  0.0,\r\n\r\n  -125.0,\r\n\r\n  0.0,\r\n\r\n  2425.0,\r\n\r\n  2425.0,\r\n\r\n  1050.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  4.0,\r\n\r\n  0.0,\r\n\r\n  -80.0,\r\n\r\n  0.0,\r\n\r\n  575.0,\r\n\r\n  575.0,\r\n\r\n  1050.0,\r\n\r\n  1.0,\r\n\r\n  1.0,\r\n\r\n  2.0,\r\n\r\n  0.0,\r\n\r\n  -80.0,\r\n\r\n  0.0,\r\n\r\n  575.0,\r\n\r\n  575.0,\r\n\r\n  1050.0,\r\n\r\n  1.0,\r\n\r\n  1.0,\r\n\r\n  3.0,\r\n\r\n  0.0,\r\n\r\n  980.0,\r\n\r\n  1520.0,\r\n\r\n  1600.0,\r\n\r\n  1050.0,\r\n\r\n  0.0,\r\n\r\n  1.0,\r\n\r\n  1.0,\r\n\r\n  0.0,\r\n\r\n  1.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  980.0,\r\n\r\n  550.0,\r\n\r\n  1050.0,\r\n\r\n  0.0,\r\n\r\n\r\n  { 1000.0, 2000.0 },\r\n\r\n\r\n  { 0.0, 638.0 },\r\n\r\n  2000.0,\r\n\r\n  1000.0,\r\n\r\n  1.0,\r\n\r\n  1.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  -60.0,\r\n\r\n  20.0,\r\n\r\n  -20.0,\r\n\r\n  0.0,\r\n\r\n  1000.0,\r\n\r\n  0.0,\r\n\r\n  1000.0,\r\n\r\n  0.0,\r\n\r\n  1000.0,\r\n\r\n\r\n  { -5.0, 5.0 },\r\n\r\n\r\n  { 982.0, 2006.0 },\r\n\r\n  5.0,\r\n\r\n  -5.0,\r\n\r\n  -0.1,\r\n\r\n  0.1,\r\n\r\n  250.0,\r\n\r\n  750.0,\r\n\r\n  -750.0,\r\n\r\n  0.0,\r\n\r\n  750.0,\r\n\r\n  -750.0,\r\n\r\n  0.0,\r\n\r\n  0.0,\r\n\r\n  1600.0,\r\n\r\n  18.4,\r\n\r\n  0.018,\r\n\r\n\r\n  { 1000.0, 2000.0 },\r\n\r\n\r\n  { 0.0, 3300.0 },\r\n\r\n  2000.0,\r\n\r\n  1000.0,\r\n\r\n  0.0,\r\n\r\n  1600.0,\r\n\r\n  0.018,\r\n\r\n\r\n  { 1000.0, 2000.0 },\r\n\r\n\r\n  { 0.0, 3300.0 },\r\n\r\n  2000.0,\r\n\r\n  1000.0,\r\n\r\n  0.0,\r\n\r\n  250.0,\r\n\r\n  0.0,\r\n\r\n  0U,\r\n\r\n  0U,\r\n\r\n  0U,\r\n\r\n\r\n  { 1U, 2U, 3U, 4U, 5U, 6U, 7U },\r\n\r\n\r\n  { 0U, 1050U, 1150U, 1350U, 1515U, 1660U, 1850U },\r\n\r\n  true,\r\n\r\n  true,\r\n\r\n  false,\r\n\r\n  true,\r\n\r\n  true,\r\n\r\n  true,\r\n\r\n  true,\r\n\r\n  true,\r\n\r\n  true,\r\n\r\n  true,\r\n\r\n  false,\r\n\r\n  false\r\n};\r\n"},{"name":"rtGetInf.cpp","type":"source","group":"utility","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Utility files","code":"#include \"rtwtypes.h\"\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rtGetInf.h\"\r\n\r\n}\r\n\r\n#include <stddef.h>\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\n#define NumBitsPerChar                 8U\r\n\r\nextern \"C\"\r\n{\r\n  real_T rtGetInf(void)\r\n  {\r\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n    real_T inf = 0.0;\r\n    if (bitsPerReal == 32U) {\r\n      inf = rtGetInfF();\r\n    } else {\r\n      union {\r\n        LittleEndianIEEEDouble bitVal;\r\n        real_T fltVal;\r\n      } tmpVal;\r\n\r\n      tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n      tmpVal.bitVal.words.wordL = 0x00000000U;\r\n      inf = tmpVal.fltVal;\r\n    }\r\n\r\n    return inf;\r\n  }\r\n\r\n  real32_T rtGetInfF(void)\r\n  {\r\n    IEEESingle infF;\r\n    infF.wordL.wordLuint = 0x7F800000U;\r\n    return infF.wordL.wordLreal;\r\n  }\r\n\r\n  real_T rtGetMinusInf(void)\r\n  {\r\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n    real_T minf = 0.0;\r\n    if (bitsPerReal == 32U) {\r\n      minf = rtGetMinusInfF();\r\n    } else {\r\n      union {\r\n        LittleEndianIEEEDouble bitVal;\r\n        real_T fltVal;\r\n      } tmpVal;\r\n\r\n      tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n      tmpVal.bitVal.words.wordL = 0x00000000U;\r\n      minf = tmpVal.fltVal;\r\n    }\r\n\r\n    return minf;\r\n  }\r\n\r\n  real32_T rtGetMinusInfF(void)\r\n  {\r\n    IEEESingle minfF;\r\n    minfF.wordL.wordLuint = 0xFF800000U;\r\n    return minfF.wordL.wordLreal;\r\n  }\r\n}\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Utility files","code":"#ifndef RTW_HEADER_rtGetInf_h_\r\n#define RTW_HEADER_rtGetInf_h_\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\n#include \"rtwtypes.h\"\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern real_T rtGetInf(void);\r\n  extern real32_T rtGetInfF(void);\r\n  extern real_T rtGetMinusInf(void);\r\n  extern real32_T rtGetMinusInfF(void);\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n#endif\r\n#endif\r\n\r\n"},{"name":"rtGetNaN.cpp","type":"source","group":"utility","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Utility files","code":"#include \"rtwtypes.h\"\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rtGetNaN.h\"\r\n\r\n}\r\n\r\n#include <stddef.h>\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\n#define NumBitsPerChar                 8U\r\n\r\nextern \"C\"\r\n{\r\n  real_T rtGetNaN(void)\r\n  {\r\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n    real_T nan = 0.0;\r\n    if (bitsPerReal == 32U) {\r\n      nan = rtGetNaNF();\r\n    } else {\r\n      union {\r\n        LittleEndianIEEEDouble bitVal;\r\n        real_T fltVal;\r\n      } tmpVal;\r\n\r\n      tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n      tmpVal.bitVal.words.wordL = 0x00000000U;\r\n      nan = tmpVal.fltVal;\r\n    }\r\n\r\n    return nan;\r\n  }\r\n\r\n  real32_T rtGetNaNF(void)\r\n  {\r\n    IEEESingle nanF = { { 0.0F } };\r\n\r\n    nanF.wordL.wordLuint = 0xFFC00000U;\r\n    return nanF.wordL.wordLreal;\r\n  }\r\n}\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Utility files","code":"#ifndef RTW_HEADER_rtGetNaN_h_\r\n#define RTW_HEADER_rtGetNaN_h_\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\n#include \"rtwtypes.h\"\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern real_T rtGetNaN(void);\r\n  extern real32_T rtGetNaNF(void);\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n#endif\r\n#endif\r\n\r\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Utility files","code":"#ifndef RTW_HEADER_rt_defines_h_\r\n#define RTW_HEADER_rt_defines_h_\r\n\r\n#define RT_PI                          3.14159265358979323846\r\n#define RT_PIF                         3.1415927F\r\n#define RT_LN_10                       2.30258509299404568402\r\n#define RT_LN_10F                      2.3025851F\r\n#define RT_LOG10E                      0.43429448190325182765\r\n#define RT_LOG10EF                     0.43429449F\r\n#define RT_E                           2.7182818284590452354\r\n#define RT_EF                          2.7182817F\r\n\r\n#ifndef UNUSED_PARAMETER\r\n#if defined(__LCC__)\r\n#define UNUSED_PARAMETER(x)\r\n#else\r\n\r\n#define UNUSED_PARAMETER(x)            (void) (x)\r\n#endif\r\n#endif\r\n#endif\r\n\r\n"},{"name":"rt_nonfinite.cpp","type":"source","group":"utility","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Utility files","code":"extern \"C\"\r\n{\r\n\r\n#include \"rtGetNaN.h\"\r\n\r\n}\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rtGetInf.h\"\r\n\r\n}\r\n\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\n#define NumBitsPerChar                 8U\r\n\r\nextern \"C\"\r\n{\r\n  real_T rtInf;\r\n  real_T rtMinusInf;\r\n  real_T rtNaN;\r\n  real32_T rtInfF;\r\n  real32_T rtMinusInfF;\r\n  real32_T rtNaNF;\r\n}\r\n\r\nextern \"C\"\r\n{\r\n  void rt_InitInfAndNaN(size_t realSize)\r\n  {\r\n    (void) (realSize);\r\n    rtNaN = rtGetNaN();\r\n    rtNaNF = rtGetNaNF();\r\n    rtInf = rtGetInf();\r\n    rtInfF = rtGetInfF();\r\n    rtMinusInf = rtGetMinusInf();\r\n    rtMinusInfF = rtGetMinusInfF();\r\n  }\r\n\r\n  boolean_T rtIsInf(real_T value)\r\n  {\r\n    return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n  }\r\n\r\n  boolean_T rtIsInfF(real32_T value)\r\n  {\r\n    return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n  }\r\n\r\n  boolean_T rtIsNaN(real_T value)\r\n  {\r\n    boolean_T result = (boolean_T) 0;\r\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n    if (bitsPerReal == 32U) {\r\n      result = rtIsNaNF((real32_T)value);\r\n    } else {\r\n      union {\r\n        LittleEndianIEEEDouble bitVal;\r\n        real_T fltVal;\r\n      } tmpVal;\r\n\r\n      tmpVal.fltVal = value;\r\n      result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\r\n                           0x7FF00000 &&\r\n                           ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                            (tmpVal.bitVal.words.wordL != 0) ));\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  boolean_T rtIsNaNF(real32_T value)\r\n  {\r\n    IEEESingle tmp;\r\n    tmp.wordL.wordLreal = value;\r\n    return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                       (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n  }\r\n}\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Utility files","code":"#ifndef RTW_HEADER_rt_nonfinite_h_\r\n#define RTW_HEADER_rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#define NOT_USING_NONFINITE_LITERALS   1\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern real_T rtInf;\r\n  extern real_T rtMinusInf;\r\n  extern real_T rtNaN;\r\n  extern real32_T rtInfF;\r\n  extern real32_T rtMinusInfF;\r\n  extern real32_T rtNaNF;\r\n  extern void rt_InitInfAndNaN(size_t realSize);\r\n  extern boolean_T rtIsInf(real_T value);\r\n  extern boolean_T rtIsInfF(real32_T value);\r\n  extern boolean_T rtIsNaN(real_T value);\r\n  extern boolean_T rtIsNaNF(real32_T value);\r\n  struct BigEndianIEEEDouble {\r\n    struct {\r\n      uint32_T wordH;\r\n      uint32_T wordL;\r\n    } words;\r\n  };\r\n\r\n  struct LittleEndianIEEEDouble {\r\n    struct {\r\n      uint32_T wordL;\r\n      uint32_T wordH;\r\n    } words;\r\n  };\r\n\r\n  struct IEEESingle {\r\n    union {\r\n      real32_T wordLreal;\r\n      uint32_T wordLuint;\r\n    } wordL;\r\n  };\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n#endif\r\n#endif\r\n\r\n"},{"name":"rt_zcfcn.cpp","type":"source","group":"utility","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Utility files","code":"#include \"zero_crossing_types.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"rt_zcfcn.h\"\r\n#include \"solver_zc.h\"\r\n\r\nextern \"C\"\r\n{\r\n  ZCEventType rt_ZCFcn(ZCDirection zcDir, ZCSigState *prevZc, real_T currValue)\r\n  {\r\n    slZcEventType zcsDir;\r\n    slZcEventType tempEv;\r\n    ZCEventType zcEvent = NO_ZCEVENT;\r\n    static const slZcEventType eventMatrix[4][4] = {\r\n      { SL_ZCS_EVENT_NUL, SL_ZCS_EVENT_Z2P, SL_ZCS_EVENT_Z2N, SL_ZCS_EVENT_NUL },\r\n\r\n      { SL_ZCS_EVENT_P2Z, SL_ZCS_EVENT_NUL, SL_ZCS_EVENT_P2N, SL_ZCS_EVENT_NUL },\r\n\r\n      { SL_ZCS_EVENT_N2Z, SL_ZCS_EVENT_N2P, SL_ZCS_EVENT_NUL, SL_ZCS_EVENT_NUL },\r\n\r\n      { SL_ZCS_EVENT_NUL, SL_ZCS_EVENT_NUL, SL_ZCS_EVENT_NUL, SL_ZCS_EVENT_NUL }\r\n    };\r\n\r\n    const slZcEventType prevEv = (slZcEventType)(((uint8_T)(*prevZc)) >> 2);\r\n    const slZcSignalSignType prevSign = (slZcSignalSignType)(((uint8_T)(*prevZc))\r\n      & (uint8_T)0x03);\r\n    const slZcSignalSignType currSign = (slZcSignalSignType)((currValue) > 0.0 ?\r\n      SL_ZCS_SIGN_POS :\r\n      ((currValue) < 0.0 ? SL_ZCS_SIGN_NEG : SL_ZCS_SIGN_ZERO));\r\n    slZcEventType currEv = eventMatrix[prevSign][currSign];\r\n    switch (zcDir) {\r\n     case ANY_ZERO_CROSSING:\r\n      zcsDir = SL_ZCS_EVENT_ALL;\r\n      break;\r\n\r\n     case FALLING_ZERO_CROSSING:\r\n      zcsDir = SL_ZCS_EVENT_ALL_DN;\r\n      break;\r\n\r\n     case RISING_ZERO_CROSSING:\r\n      zcsDir = SL_ZCS_EVENT_ALL_UP;\r\n      break;\r\n\r\n     default:\r\n      zcsDir = SL_ZCS_EVENT_NUL;\r\n      break;\r\n    }\r\n\r\n    if (slZcHadEvent(currEv, zcsDir)) {\r\n      currEv = (slZcEventType)(slZcUnAliasEvents(prevEv, currEv));\r\n    } else {\r\n      currEv = SL_ZCS_EVENT_NUL;\r\n    }\r\n\r\n    tempEv = (slZcEventType)(currEv << 2);\r\n    *prevZc = (ZCSigState)((currSign) | (tempEv));\r\n    if ((currEv & SL_ZCS_EVENT_ALL_DN) != 0) {\r\n      zcEvent = FALLING_ZCEVENT;\r\n    } else if ((currEv & SL_ZCS_EVENT_ALL_UP) != 0) {\r\n      zcEvent = RISING_ZCEVENT;\r\n    } else {\r\n      zcEvent = NO_ZCEVENT;\r\n    }\r\n\r\n    return zcEvent;\r\n  }\r\n}\r\n"},{"name":"rt_zcfcn.h","type":"header","group":"utility","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Utility files","code":"#ifndef RTW_HEADER_rt_zcfcn_h_\r\n#define RTW_HEADER_rt_zcfcn_h_\r\n#include \"zero_crossing_types.h\"\r\n#include \"rtwtypes.h\"\r\n#ifndef slZcHadEvent\r\n#define slZcHadEvent(ev, zcsDir)       (((ev) & (zcsDir)) != 0x00 )\r\n#endif\r\n\r\n#ifndef slZcUnAliasEvents\r\n#define slZcUnAliasEvents(evL, evR)    ((((slZcHadEvent((evL), (SL_ZCS_EVENT_N2Z)) && slZcHadEvent((evR), (SL_ZCS_EVENT_Z2P))) || (slZcHadEvent((evL), (SL_ZCS_EVENT_P2Z)) && slZcHadEvent((evR), (SL_ZCS_EVENT_Z2N)))) ? (SL_ZCS_EVENT_NUL) : (evR)))\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern ZCEventType rt_ZCFcn(ZCDirection zcDir, ZCSigState *prevZc, real_T\r\n    currValue);\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n#endif\r\n#endif\r\n\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Utility files","code":"#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n"},{"name":"zero_crossing_types.h","type":"header","group":"utility","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Utility files","code":"#ifndef ZERO_CROSSING_TYPES_H\r\n#define ZERO_CROSSING_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\ntypedef enum {\r\n  FALLING_ZERO_CROSSING = -1,\r\n  ANY_ZERO_CROSSING = 0,\r\n  RISING_ZERO_CROSSING = 1\r\n} ZCDirection;\r\n\r\ntypedef uint8_T ZCSigState;\r\n\r\n#define UNINITIALIZED_ZCSIG            0x03U\r\n#define NEG_ZCSIG                      0x02U\r\n#define POS_ZCSIG                      0x01U\r\n#define ZERO_ZCSIG                     0x00U\r\n\r\ntypedef enum { FALLING_ZCEVENT = -1, NO_ZCEVENT = 0, RISING_ZCEVENT = 1 }\r\n  ZCEventType;\r\n\r\n#endif\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Interface files","code":"#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"buildover_fullstatemachine.h\"\r\n\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif\r\n\r\n"},{"name":"MW_PX4_PWM.cpp","type":"source","group":"legacy","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\px4\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018-2023 The MathWorks, Inc. */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n#include \"MW_PX4_PWM.h\"\n\n#ifndef MW_PWM_MAIN_ONESHOT\n#define MW_PWM_MAIN_ONESHOT 0\n#endif\n\n#ifndef MW_PWM_MAIN_FREQUENCY\n#define MW_PWM_MAIN_FREQUENCY 0\n#endif\n\n#ifndef MW_PWM_AUX_ONESHOT\n#define MW_PWM_AUX_ONESHOT 0\n#endif\n\n#ifndef MW_PWM_AUX_FREQUENCY\n#define MW_PWM_AUX_FREQUENCY 0\n#endif\n\n#ifndef MW_PWM_CH1_FAILSAFE\n#define MW_PWM_CH1_FAILSAFE 0\n#endif\n\n#ifndef MW_PWM_CH1_DISARMED\n#define MW_PWM_CH1_DISARMED 0\n#endif\n\n#ifndef MW_PWM_CH2_FAILSAFE\n#define MW_PWM_CH2_FAILSAFE 0\n#endif\n\n#ifndef MW_PWM_CH2_DISARMED\n#define MW_PWM_CH2_DISARMED 0\n#endif\n\n#ifndef MW_PWM_CH3_FAILSAFE\n#define MW_PWM_CH3_FAILSAFE 0\n#endif\n\n#ifndef MW_PWM_CH3_DISARMED\n#define MW_PWM_CH3_DISARMED 0\n#endif\n\n#ifndef MW_PWM_CH4_FAILSAFE\n#define MW_PWM_CH4_FAILSAFE 0\n#endif\n\n#ifndef MW_PWM_CH4_DISARMED\n#define MW_PWM_CH4_DISARMED 0\n#endif\n\n#ifndef MW_PWM_CH5_FAILSAFE\n#define MW_PWM_CH5_FAILSAFE 0\n#endif\n\n#ifndef MW_PWM_CH5_DISARMED\n#define MW_PWM_CH5_DISARMED 0\n#endif\n\n#ifndef MW_PWM_CH6_FAILSAFE\n#define MW_PWM_CH6_FAILSAFE 0\n#endif\n\n#ifndef MW_PWM_CH6_DISARMED\n#define MW_PWM_CH6_DISARMED 0\n#endif\n\n#ifndef MW_PWM_CH7_FAILSAFE\n#define MW_PWM_CH7_FAILSAFE 0\n#endif\n\n#ifndef MW_PWM_CH7_DISARMED\n#define MW_PWM_CH7_DISARMED 0\n#endif\n\n#ifndef MW_PWM_CH8_FAILSAFE\n#define MW_PWM_CH8_FAILSAFE 0\n#endif\n\n#ifndef MW_PWM_CH8_DISARMED\n#define MW_PWM_CH8_DISARMED 0\n#endif\n\n#ifndef MW_PWM_AUX_CH1_FAILSAFE\n#define MW_PWM_AUX_CH1_FAILSAFE 0\n#endif\n\n#ifndef MW_PWM_AUX_CH1_DISARMED\n#define MW_PWM_AUX_CH1_DISARMED 0\n#endif\n\n#ifndef MW_PWM_AUX_CH2_FAILSAFE\n#define MW_PWM_AUX_CH2_FAILSAFE 0\n#endif\n\n#ifndef MW_PWM_AUX_CH2_DISARMED\n#define MW_PWM_AUX_CH2_DISARMED 0\n#endif\n\n#ifndef MW_PWM_AUX_CH3_FAILSAFE\n#define MW_PWM_AUX_CH3_FAILSAFE 0\n#endif\n\n#ifndef MW_PWM_AUX_CH3_DISARMED\n#define MW_PWM_AUX_CH3_DISARMED 0\n#endif\n\n#ifndef MW_PWM_AUX_CH4_FAILSAFE\n#define MW_PWM_AUX_CH4_FAILSAFE 0\n#endif\n\n#ifndef MW_PWM_AUX_CH4_DISARMED\n#define MW_PWM_AUX_CH4_DISARMED 0\n#endif\n\n#ifndef MW_PWM_AUX_CH5_FAILSAFE\n#define MW_PWM_AUX_CH5_FAILSAFE 0\n#endif\n\n#ifndef MW_PWM_AUX_CH5_DISARMED\n#define MW_PWM_AUX_CH5_DISARMED 0\n#endif\n\n#ifndef MW_PWM_AUX_CH6_FAILSAFE\n#define MW_PWM_AUX_CH6_FAILSAFE 0\n#endif\n\n#ifndef MW_PWM_AUX_CH6_DISARMED\n#define MW_PWM_AUX_CH6_DISARMED 0\n#endif\n\n#ifndef MW_PWM_AUX_CH7_FAILSAFE\n#define MW_PWM_AUX_CH7_FAILSAFE 0\n#endif\n\n#ifndef MW_PWM_AUX_CH7_DISARMED\n#define MW_PWM_AUX_CH7_DISARMED 0\n#endif\n\n#ifndef MW_PWM_AUX_CH8_FAILSAFE\n#define MW_PWM_AUX_CH8_FAILSAFE 0\n#endif\n\n#ifndef MW_PWM_AUX_CH8_DISARMED\n#define MW_PWM_AUX_CH8_DISARMED 0\n#endif\n\n#define DEBUG 0\n\n#define PWM_SUCCESS 0\n#define PWM_OPEN_FAIL 1\n#define PWM_SERVOCOUNT_FAIL 2\n#define PWM_ARM_FAIL 4\n#define PWM_DISARM_FAIL 8\n#define PWM_SETRATE_FAIL 16\n#define PWM_SETCHANNEL_FAIL 32\n#define PWM_SETFS_FAIL 64\n#define PWM_SETDA_FAIL 128\n#define PWM_FORCEFS_FAIL 256\n#define PWM_FORCETERMFS_FAIL 512\n#define PWM_SETSERVO_FAIL 1024\n#define PWM_RESETSERVO_FAIL 2048\n#define PWM_CLOSE_FAIL 4096\n\nunsigned pwm_open(int* pwmHandler, \n                  const char* pwmDevice, \n                  orb_advert_t* actuatorObj,\n                  orb_advert_t* armObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"* pwm_open: PWM Device: %s * \", pwmDevice);\n    PX4_INFO(\"*     actuatorObj: %d * \", actuatorObj);\n    PX4_INFO(\"*     armObj: %d *\\n\", armObj);\n#endif\n#if USE_IOCTL    \n    int fd = px4_open(pwmDevice, 0);\n\n    if (fd < 0) {\n        PX4_ERR(\"can't open %s\", pwmDevice);\n        return PWM_OPEN_FAIL;\n    }\n    *pwmHandler = fd;\n\n    PX4_INFO(\"* Opened PWM Device: %s (fd = %d)*\\n\", pwmDevice, *pwmHandler);\n#else\n    *pwmHandler = 0;\n\t/* advertise actuator_outputs topic */\n\tstruct actuator_outputs_s outputs;\n\tmemset(&outputs, 0, sizeof(outputs));\n\t*actuatorObj = orb_advertise_queue(ORB_ID(actuator_outputs), &outputs, 1);    \n\n\t/* advertise actuator_armed topic */\n\tstruct actuator_armed_s armPWM;\n\tmemset(&armPWM, 0, sizeof(armPWM));\n\t*armObj = orb_advertise_queue(ORB_ID(actuator_armed), &armPWM, 1);       \n#endif\n    return PWM_SUCCESS;\n}\n\nunsigned pwm_getServoCount(const int* pwmHandler, unsigned* servoCount) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"* pwm_getServoCount: *pwmHandler (fd = %d)* \", *pwmHandler);\n#endif\n    /* get the number of servo channels */\n#if USE_IOCTL   \n    unsigned servo_count;\n    int fd = *pwmHandler;\n    int ret = px4_ioctl(fd, PWM_SERVO_GET_COUNT, (unsigned long)&servo_count);\n\n    if (ret != OK) {\n#if DEBUG\n        PX4_ERR(\"PWM_SERVO_GET_COUNT\");\n#endif\n        return PWM_SERVOCOUNT_FAIL;\n    }\n#if DEBUG\n    PX4_INFO(\"Number of servo channels is %d\", servo_count);\n#endif\n\n    *servoCount = servo_count;\n#else\n    *servoCount = 8;\n#endif\n    return PWM_SUCCESS;\n}\n\nunsigned pwm_arm(const int* pwmHandler,\n                 orb_advert_t* armObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"* pwm_arm: *pwmHandler (fd = %d)* \", *pwmHandler);\n    PX4_INFO(\"*     armObj: %d *\\n\", armObj);\n#endif\n    /* tell safety that its ok to disable it with the switch */\n#if USE_IOCTL      \n    int fd = *pwmHandler;\n    int ret = px4_ioctl(fd, PWM_SERVO_SET_ARM_OK, 0);\n\n    if (ret != OK) {\n#if DEBUG\n        err(1, \"PWM_SERVO_SET_ARM_OK\");\n#endif\n    }\n\n    /* tell IO that the system is armed (it will output values if safety is off) */\n    ret = px4_ioctl(fd, PWM_SERVO_ARM, 0);\n\n    if (ret != OK) {\n#if DEBUG\n        err(1, \"PWM_SERVO_ARM\");\n#endif\n        return PWM_ARM_FAIL;\n    }\n\n\tif (::ioctl(fd, PWM_SERVO_SET_MODE, PWM_SERVO_ENTER_TEST_MODE) < 0) {\n#if DEBUG \n        err(1, \"PWM_SERVO_ENTER_TEST_MODE\");\n#endif        \n\t}    \n#else\n\tstruct actuator_armed_s armPWM;\n\tmemset(&armPWM, 0, sizeof(armPWM));\n    armPWM.armed = true;\n    orb_publish(ORB_ID(actuator_armed), *armObj, &armPWM);\n#endif\n    return PWM_SUCCESS;\n}\n\nunsigned pwm_disarm(const int* pwmHandler,\n                    orb_advert_t* armObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"* pwm_disarm: *pwmHandler (fd = %d)* \", *pwmHandler);\n    PX4_INFO(\"*     armObj: %d *\\n\", armObj);\n#endif\n    /* disarm, but do not revoke the SET_ARM_OK flag */\n#if USE_IOCTL   \n    int fd = *pwmHandler;\n    int ret = px4_ioctl(fd, PWM_SERVO_DISARM, 0);\n\n    if (ret != OK) {\n#if DEBUG\n        err(1, \"PWM_SERVO_DISARM\");\n#endif\n        return PWM_DISARM_FAIL;\n    }\n#else\n\tstruct actuator_armed_s armPWM;\n\tmemset(&armPWM, 0, sizeof(armPWM));\n    armPWM.armed = false;\n    orb_publish(ORB_ID(actuator_armed), *armObj, &armPWM);\n\n#if defined(MW_PX4_POSIX_BUILD)\n\tstruct vehicle_status_s arm_vehicle_stat;\n    /* Subscribe to current vehicle_status*/\n    int vehicle_status_fd = orb_subscribe(ORB_ID(vehicle_status));  \n    orb_copy(ORB_ID(vehicle_status), vehicle_status_fd, &arm_vehicle_stat);\n    /* Arm vehicle status to ARMING_STATE_SHUTDOWN = 4*/\n    arm_vehicle_stat.arming_state = 4;\n    static bool isAdvertised_disarm = false;\n    static orb_advert_t vehicle_status_pub;\n    if(!isAdvertised_disarm) {\n        isAdvertised_disarm = true;\n        vehicle_status_pub = orb_advertise_queue(ORB_ID(vehicle_status), &arm_vehicle_stat, 1);\n    }\n    orb_publish(ORB_ID(vehicle_status), vehicle_status_pub, &arm_vehicle_stat);\n    \n    orb_unsubscribe(vehicle_status_fd);\n#endif  \n    \n#endif\n    return PWM_SUCCESS;\n}\n\nunsigned pwm_setPWMRate(const int* pwmHandler, boolean_T isMain) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))    \n    PX4_INFO(\"* pwm_setPWMRate: *pwmHandler (fd = %d)* \", *pwmHandler);\n    PX4_INFO(\"*     isMain %d* \\n\", isMain);\n#endif\n#if USE_IOCTL   \n    /* Change alternate PWM rate or set oneshot\n     * Either the \"oneshot\" command was used\n     * OR rate was provided, so we will issue the\n     * PWM_SERVO_SET_UPDATE_RATE ioctl\n     */\n    int fd = *pwmHandler;\n#ifndef PX4_CONNECTEDIO\n    int rate = 0;\n    if (isMain) {\n#if defined(MW_PWM_MAIN_ONESHOT) && (MW_PWM_MAIN_ONESHOT == 1)\n        rate = 0; /*Set rate as 0 for oneshot*/\n#else\n        rate = MW_PWM_MAIN_FREQUENCY;\n#endif\n    } else {\n#if defined(MW_PWM_AUX_ONESHOT) && (MW_PWM_AUX_ONESHOT == 1)\n        rate = 0; /*Set rate as 0 for oneshot*/\n#else\n        rate = MW_PWM_AUX_FREQUENCY;\n#endif\n    }\n#else\n\textern int rate;\n#endif\n#if DEBUG\n    PX4_INFO(\"Frequency %d:\", rate);\n#endif\n\n    int ret = px4_ioctl(fd, PWM_SERVO_SET_UPDATE_RATE, rate);\n\n    if (ret != OK) {\n\n#if DEBUG\n        PX4_ERR(\"PWM_SERVO_SET_UPDATE_RATE (check rate for sanity)\");\n#endif\n        return PWM_SETRATE_FAIL;\n    }\n#else\n\n#endif    \n\n    return PWM_SUCCESS;\n}\n\nunsigned pwm_setChannelMask(const int* pwmHandler, int channelMask) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))    \n    PX4_INFO(\"* pwm_setChannelMask: *pwmHandler (fd = %d)* \", *pwmHandler);\n    PX4_INFO(\"*     channelMask %d*\\n\", channelMask);\n#endif\n#if USE_IOCTL  \n    int fd = *pwmHandler;\n    int ret = px4_ioctl(fd, PWM_SERVO_SET_SELECT_UPDATE_RATE, channelMask);\n\n    if (ret != OK) {\n#if DEBUG\n        PX4_ERR(\"PWM_SERVO_SET_SELECT_UPDATE_RATE\");\n#endif\n        return PWM_SETCHANNEL_FAIL;\n    }\n#else\n\n#endif    \n    return PWM_SUCCESS;\n}\n\nunsigned pwm_setDisarmedPWM(const int* pwmHandler,\n                            unsigned servo_count,\n                            int channelMask,\n                            boolean_T isMain,\n                            orb_advert_t* actuatorObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))    \n    PX4_INFO(\"* pwm_setDisarmedPWM: *pwmHandler (fd = %d)* \", *pwmHandler);\n    PX4_INFO(\"*     servo_count %d* \", servo_count);\n    PX4_INFO(\"*     channelMask %d* \", channelMask);\n    PX4_INFO(\"*     isMain %d* \", isMain);\n    PX4_INFO(\"*     actuatorObj %d* \\n\", actuatorObj);\n#endif\n#if USE_IOCTL                               \n    struct pwm_output_values pwm_values;\n\n    memset(&pwm_values, 0, sizeof(pwm_values));\n\n    pwm_values.channel_count = servo_count;\n\n    /* first get current state before modifying it */\n    int fd = *pwmHandler;\n    int ret = px4_ioctl(fd, PWM_SERVO_GET_DISARMED_PWM, (long unsigned int)&pwm_values);\n\n    if (ret != OK) {\n#if DEBUG\n        PX4_ERR(\"failed get disarmed values\");\n#endif\n    }\n#ifndef PX4_CONNECTEDIO\t\n    int pwmValue[8];\n    getDAPWMValues(isMain, pwmValue);\n#else\n\textern int pwmValue[];\n#endif\n    \n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))        \n    uint32_T iPWM;\n    printf(\"pwm_setDisarmedPWM: PWM values :\");\n    for (iPWM= 0;iPWM<8;iPWM++)\n    {\n        printf(\"[%d]\",pwmValue[iPWM]);\n    }\n    printf(\"\\n\");\n#endif    \n    \n    for (unsigned i = 0; i < servo_count; i++) {\n        if (channelMask & 1 << i) {\n            pwm_values.values[i] = pwmValue[i];\n        }\n    }\n\n    ret = px4_ioctl(fd, PWM_SERVO_SET_DISARMED_PWM, (long unsigned int)&pwm_values);\n\n    if (ret != OK) {\n#if DEBUG\n        PX4_ERR(\"failed setting disarmed values (%d)\", ret);\n#endif\n        return PWM_SETDA_FAIL;\n    }\n#else\n    if(isMain)\n    {\t\t\n#ifndef PX4_CONNECTEDIO\t\n\t\tint pwmValue[8];\n\t\tgetDAPWMValues(true, pwmValue);\n#else\n\t\textern int pwmValue[];\n#endif\n\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))        \n        uint32_T iPWM;\n        printf(\"pwm_setDisarmedPWM: PWM values :\");\n        for (iPWM= 0;iPWM<8;iPWM++)\n        {\n            printf(\"[%d]\",pwmValue[iPWM]);\n        }\n        printf(\"\\n\");\n#endif\n        struct actuator_outputs_s outputs;\n        memset(&outputs, 0, sizeof(outputs));\n        outputs.noutputs = servo_count;\n        outputs.timestamp = hrt_absolute_time();\n        for (unsigned i = 0; i < servo_count; i++) {\n            if (channelMask & 1 << i) {\n            outputs.output[i] =  pwmValue[i]; \n            }\n        }\n        orb_publish(ORB_ID(actuator_outputs), *actuatorObj, &outputs);\n    }\n#endif\n        return PWM_SUCCESS;\n\n\n}\n\nunsigned pwm_setFailsafePWM(const int* pwmHandler,\n                            unsigned servo_count,\n                            int channelMask,\n                            boolean_T isMain) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))    \n    PX4_INFO(\"* pwm_setFailsafePWM: *pwmHandler (fd = %d)* \", *pwmHandler);\n    PX4_INFO(\"*     servo_count %d* \", servo_count);\n    PX4_INFO(\"*     channelMask %d* \", channelMask);\n    PX4_INFO(\"*     isMain %d* \\n\", isMain);\n#endif\n#if USE_IOCTL                                 \n    struct pwm_output_values pwm_values;\n\n    memset(&pwm_values, 0, sizeof(pwm_values));\n\n    pwm_values.channel_count = servo_count;\n\n    /* first get current state before modifying it */\n    int fd = *pwmHandler;\n    int ret = px4_ioctl(fd, PWM_SERVO_GET_FAILSAFE_PWM, (long unsigned int)&pwm_values);\n\n    if (ret != OK) {\n#if DEBUG\n        PX4_ERR(\"failed get failsafe values\");\n#endif\n    }\n#ifndef PX4_CONNECTEDIO\t\n    int pwmValue[8];\n    getFSPWMValues(isMain, pwmValue);\n#else\n\textern int pwmValue[];\n#endif\n    \n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))    \n    uint32_T iPWM;\n    printf(\"pwm_setFailsafePWM: PWM values :\");\n    for (iPWM= 0;iPWM<8;iPWM++)\n    {\n        printf(\"[%d]\",pwmValue[iPWM]);\n    }\n    printf(\"\\n\");\n#endif    \n    for (unsigned i = 0; i < servo_count; i++) {\n        if (channelMask & 1 << i) {\n            pwm_values.values[i] = pwmValue[i];\n        }\n    }\n\n    ret = px4_ioctl(fd, PWM_SERVO_SET_FAILSAFE_PWM, (long unsigned int)&pwm_values);\n\n    if (ret != OK) {\n#if DEBUG\n        PX4_ERR(\"failed setting failsafe values (%d)\", ret);\n#endif\n        return PWM_SETFS_FAIL;\n    }\n#else\n    \n#endif\n    return PWM_SUCCESS;\n\n}\n\nunsigned pwm_forceFailsafe(const int* pwmHandler, int value) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))    \n    PX4_INFO(\"* pwm_forceFailsafe: *pwmHandler (fd = %d)* \", *pwmHandler);\n    PX4_INFO(\"*     value %d*\\n\", value);\n#endif    \n#if USE_IOCTL      \n    /*force failsafe: 1 - on, 0 - off*/\n    int fd = *pwmHandler;\n    int ret = px4_ioctl(fd, PWM_SERVO_SET_FORCE_FAILSAFE, value);\n    if (ret != OK) {\n#if DEBUG\n        PX4_ERR(\"FAILED setting forcefail\");\n#endif\n        return PWM_FORCEFS_FAIL;\n    }\n#else\n\n#endif\n    return PWM_SUCCESS;\n}\n\nunsigned pwm_forceTerminateFailsafe(const int* pwmHandler, int value) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))    \n    PX4_INFO(\"* pwm_forceTerminateFailsafe: *pwmHandler (fd = %d)* \", *pwmHandler);\n    PX4_INFO(\"*     value %d*\\n\", value);\n#endif\n#if USE_IOCTL     \n    /*force terminate failsafe: 1 - on, 0 - off*/\n    int fd = *pwmHandler;\n    int ret = px4_ioctl(fd, PWM_SERVO_SET_TERMINATION_FAILSAFE, value);\n    if (ret != OK) {\n#if DEBUG\n        PX4_ERR(\"FAILED setting termination forcefail\");\n#endif\n        return PWM_FORCETERMFS_FAIL;\n    }\n#else\n\n#endif\n    return PWM_SUCCESS;\n}\n\nunsigned pwm_setServo(const int* pwmHandler,\n                      unsigned servo_count,\n                      int channelMask,\n                      uint16_t* pwm_value,\n                      boolean_T isMain,\n                      orb_advert_t* actuatorObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))    \n    PX4_INFO(\"* pwm_setServo: *pwmHandler (fd = %d)* \", *pwmHandler);\n    PX4_INFO(\"*     servo_count %d* \", servo_count);\n    PX4_INFO(\"*     isMain %d* \", isMain);\n    PX4_INFO(\"*     actuatorObj %d* \\n\", actuatorObj);\n    uint32_T iPWM;\n    printf(\"* pwm_setServo: PWM values :\");\n    for (iPWM= 0;iPWM<8;iPWM++)\n    {\n        printf(\"[%d]\",pwm_value[iPWM]);\n    }\n    printf(\"\\n\");\n#endif    \n#if USE_IOCTL                           \n    int fd = *pwmHandler;\n    int ret;\n    for (unsigned i = 0; i < servo_count; i++) {\n        if (channelMask & 1 << i) {\n            ret = px4_ioctl(fd, PWM_SERVO_SET(i), pwm_value[i]);\n\n            if (ret != OK) {\n#if DEBUG\n                PX4_ERR(\"PWM_SERVO_SET(%d)\", i);\n#endif\n                return PWM_SETSERVO_FAIL;\n            }\n        }\n    }\n    \n/* add a delay longer than the max Oneshot duration if Oneshot is enabled */    \naddDelayOneshot(isMain);\n\n#ifdef __PX4_NUTTX\n    /* Trigger all timer's channels in Oneshot mode to fire\n     * the oneshots with updated values.\n     */\n    up_pwm_update();\n#endif\n\n#else\n    if(isMain)\n    {\n        struct actuator_outputs_s outputs;\n        memset(&outputs, 0, sizeof(outputs));\n        outputs.noutputs = servo_count;\n        outputs.timestamp = hrt_absolute_time();\n       for (unsigned i = 0; i < servo_count; i++) {\n            if (channelMask & 1 << i) {\n               outputs.output[i] =  pwm_value[i]; \n            }\n        }\n        orb_publish(ORB_ID(actuator_outputs), *actuatorObj, &outputs);\n\n#if defined(MW_PX4_POSIX_BUILD)\n        /*Only for Host target vehicle_status needs to be armed, not for HITL*/\n        struct vehicle_status_s arm_vehicle_stat;\n        /* Subscribe to current vehicle_status*/\n        int vehicle_status_fd = orb_subscribe(ORB_ID(vehicle_status));\n        orb_copy(ORB_ID(vehicle_status), vehicle_status_fd, &arm_vehicle_stat);\n        /* Arm vehicle status to ARMING_STATE_ARMED = 2*/\n        arm_vehicle_stat.arming_state = 2;\n        orb_advert_t vehicle_status_pub = orb_advertise_queue(ORB_ID(vehicle_status), &arm_vehicle_stat, 1);\n        orb_publish(ORB_ID(vehicle_status), vehicle_status_pub, &arm_vehicle_stat);\n        orb_unsubscribe(vehicle_status_fd);\n#endif  \n\n    }\n#endif    \n    return PWM_SUCCESS;\n}\n\nunsigned pwm_resetServo(const int* pwmHandler,\n                        unsigned servo_count,\n                        int channelMask,\n                        boolean_T isMain,\n                        orb_advert_t* actuatorObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))    \n    PX4_INFO(\"* pwm_resetServo: *pwmHandler (fd = %d)* \", *pwmHandler);\n    PX4_INFO(\"*     servo_count %d* \", servo_count);\n    PX4_INFO(\"*     isMain %d* \", isMain);\n    PX4_INFO(\"*     actuatorObj %d* \\n\", actuatorObj);\n#endif\n#if USE_IOCTL                            \n    int fd = *pwmHandler;\n    int ret;\n\n#ifndef PX4_CONNECTEDIO\t\n    int pwmValue[8];\n    getDAPWMValues(isMain, pwmValue);\n#else\n\textern int pwmValue[];\n#endif\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))    \n    uint32_T iPWM;\n    printf(\"pwm_resetServo: PWM values :\");\n    for (iPWM= 0;iPWM<8;iPWM++)\n    {\n        printf(\"[%d]\",pwmValue[iPWM]);\n    }\n    printf(\"\\n\");\n#endif\n    for (unsigned i = 0; i < servo_count; i++) {\n        if (channelMask & 1 << i) {\n            ret = px4_ioctl(fd, PWM_SERVO_SET(i), pwmValue[i]);\n\n            if (ret != OK) {\n#if DEBUG\n                PX4_ERR(\"PWM_SERVO_SET(%d)\", i);\n#endif\n                return PWM_RESETSERVO_FAIL;\n            }\n        }\n    }\n\n#else\n    if(isMain)\n    {\n#ifndef PX4_CONNECTEDIO\t\n\t\tint pwmValue[8];\n\t\tgetDAPWMValues(true, pwmValue);\n#else\n\t\textern int pwmValue[];\n#endif\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))    \n        uint32_T iPWM;\n        printf(\"pwm_resetServo: PWM values :\");\n        for (iPWM= 0;iPWM<8;iPWM++)\n        {\n            printf(\"[%d]\",pwmValue[iPWM]);\n        }\n        printf(\"\\n\");\n#endif        \n        struct actuator_outputs_s outputs;\n        memset(&outputs, 0, sizeof(outputs));\n        outputs.noutputs = servo_count;\n        outputs.timestamp = hrt_absolute_time();\n    for (unsigned i = 0; i < servo_count; i++) {\n            if (channelMask & 1 << i) {\n            outputs.output[i] =  pwmValue[i]; \n            }\n        }\n        orb_publish(ORB_ID(actuator_outputs), *actuatorObj, &outputs);\n    }\n\n#endif\n    return PWM_SUCCESS;\n\n}\n\nunsigned pwm_close(const int* pwmHandler, orb_advert_t* actuatorObj, orb_advert_t* armObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"* pwm_close: *pwmHandler (fd = %d)* \", *pwmHandler);\n    PX4_INFO(\"*     armObj %d* \", armObj);\n    PX4_INFO(\"*     actuatorObj %d*\\n\", actuatorObj);\n#endif\n#if USE_IOCTL      \n    int fd = *pwmHandler;\n    /** clear the 'ARM ok' bit, which deactivates the safety switch */\n    px4_ioctl(fd, PWM_SERVO_CLEAR_ARM_OK, 0);\n    px4_close(fd);\n#else\n    orb_unadvertise(*actuatorObj);\n    orb_unadvertise(*armObj);\n#endif\n    return PWM_SUCCESS;\n}\n\nvoid getFSPWMValues(boolean_T isMain, int* fsPWMvalues) {\n\n    for (int index = 0; index < 8; index++) {\n        if (isMain) {\n            switch (index) {\n            case 0:\n                fsPWMvalues[index] = MW_PWM_CH1_FAILSAFE;\n                break;\n            case 1:\n                fsPWMvalues[index] = MW_PWM_CH2_FAILSAFE;\n                break;\n            case 2:\n                fsPWMvalues[index] = MW_PWM_CH3_FAILSAFE;\n                break;\n            case 3:\n                fsPWMvalues[index] = MW_PWM_CH4_FAILSAFE;\n                break;\n            case 4:\n                fsPWMvalues[index] = MW_PWM_CH5_FAILSAFE;\n                break;\n            case 5:\n                fsPWMvalues[index] = MW_PWM_CH6_FAILSAFE;\n                break;\n            case 6:\n                fsPWMvalues[index] = MW_PWM_CH7_FAILSAFE;\n                break;\n            case 7:\n                fsPWMvalues[index] = MW_PWM_CH8_FAILSAFE;\n                break;\n            }\n        } else {\n            switch (index) {\n            case 0:\n                fsPWMvalues[index] = MW_PWM_AUX_CH1_FAILSAFE;\n                break;\n            case 1:\n                fsPWMvalues[index] = MW_PWM_AUX_CH2_FAILSAFE;\n                break;\n            case 2:\n                fsPWMvalues[index] = MW_PWM_AUX_CH3_FAILSAFE;\n                break;\n            case 3:\n                fsPWMvalues[index] = MW_PWM_AUX_CH4_FAILSAFE;\n                break;\n            case 4:\n                fsPWMvalues[index] = MW_PWM_AUX_CH5_FAILSAFE;\n                break;\n            case 5:\n                fsPWMvalues[index] = MW_PWM_AUX_CH6_FAILSAFE;\n                break;\n            case 6:\n                fsPWMvalues[index] = MW_PWM_AUX_CH7_FAILSAFE;\n                break;\n            case 7:\n                fsPWMvalues[index] = MW_PWM_AUX_CH8_FAILSAFE;\n                break;\n            }\n        }\n    }\n}\n\nvoid getDAPWMValues(boolean_T isMain, int* daPWMvalues) {\n\n    for (int index = 0; index < 8; index++) {\n        if (isMain) {\n            switch (index) {\n            case 0:\n                daPWMvalues[index] = MW_PWM_CH1_DISARMED;\n                break;\n            case 1:\n                daPWMvalues[index] = MW_PWM_CH2_DISARMED;\n                break;\n            case 2:\n                daPWMvalues[index] = MW_PWM_CH3_DISARMED;\n                break;\n            case 3:\n                daPWMvalues[index] = MW_PWM_CH4_DISARMED;\n                break;\n            case 4:\n                daPWMvalues[index] = MW_PWM_CH5_DISARMED;\n                break;\n            case 5:\n                daPWMvalues[index] = MW_PWM_CH6_DISARMED;\n                break;\n            case 6:\n                daPWMvalues[index] = MW_PWM_CH7_DISARMED;\n                break;\n            case 7:\n                daPWMvalues[index] = MW_PWM_CH8_DISARMED;\n                break;\n            }\n        } else {\n            switch (index) {\n            case 0:\n                daPWMvalues[index] = MW_PWM_AUX_CH1_DISARMED;\n                break;\n            case 1:\n                daPWMvalues[index] = MW_PWM_AUX_CH2_DISARMED;\n                break;\n            case 2:\n                daPWMvalues[index] = MW_PWM_AUX_CH3_DISARMED;\n                break;\n            case 3:\n                daPWMvalues[index] = MW_PWM_AUX_CH4_DISARMED;\n                break;\n            case 4:\n                daPWMvalues[index] = MW_PWM_AUX_CH5_DISARMED;\n                break;\n            case 5:\n                daPWMvalues[index] = MW_PWM_AUX_CH6_DISARMED;\n                break;\n            case 6:\n                daPWMvalues[index] = MW_PWM_AUX_CH7_DISARMED;\n                break;\n            case 7:\n                daPWMvalues[index] = MW_PWM_AUX_CH8_DISARMED;\n                break;\n            }\n        }\n    }\n}\n\nvoid addDelayOneshot(boolean_T isMain)\n{\n#ifndef PX4_CONNECTEDIO\t\n\tboolean_T isOneShot = false;\n    if (isMain) {\n#if defined(MW_PWM_MAIN_ONESHOT) && (MW_PWM_MAIN_ONESHOT == 1)\n            isOneShot = true; \n#endif\n        } else {\n#if defined(MW_PWM_AUX_ONESHOT) && (MW_PWM_AUX_ONESHOT == 1)\n            isOneShot = true; \n#endif\n        }\n#else\n\textern boolean_T isOneShot;\n#endif\n\tif(isOneShot)\n\t{\n    /* Delay longer than the max Oneshot duration */\n    usleep(2542);\n\t}\n}\n"},{"name":"MW_PX4_TaskControl.cpp","type":"source","group":"legacy","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\px4\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2018-2022 The MathWorks, Inc.\n *\n * File: MW_PX4_TaskControl.c\n *\n * Abstract:\n *  This file contains the main application for Simulink that is launched\n *  by PX4 stack at boot up. The main function spawns a new task and assigns\n *  the main function in ert_main.c as callback.\n *\n */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n/*Simulink model generated code specific headers*/\n\n#define MW_StringifyDefine(x) MW_StringifyDefineExpanded(x)\n#define MW_StringifyDefineExpanded(x) #x\n\n#define MW_StringifyDefineFunction(x, y) MW_StringifyDefineExpandedFunction(x, y)\n#define MW_StringifyDefineExpandedFunction(x, y) x##y\n\n#define MW_StringifyDefineX(x) MW_StringifyDefineExpandedX(x)\n#define MW_StringifyDefineExpandedX(x) x.##h\n\n#define MW_StringifyDefineTypesX(x) MW_StringifyDefineExpandedTypesX(x)\n#define MW_StringifyDefineExpandedTypesX(x) x##_types.h\n\n#define MW_StringifyDefinePrivateX(x) MW_StringifyDefineExpandedPrivateX(x)\n#define MW_StringifyDefineExpandedPrivateX(x) x##_private.h\n\n#include MW_StringifyDefine(MODEL.h)\n#include MW_StringifyDefine(MW_StringifyDefineTypesX(MODEL))\n#include MW_StringifyDefine(MW_StringifyDefinePrivateX(MODEL))\n\n#ifndef MW_PX4_DISABLE_MAVLINK\n#include \"mavlink_main.h\"\n#endif\n\n#define DEBUG 0\n\n#ifdef PIL\nextern int errorOccurred;\n#endif\n\nextern \"C\" __EXPORT int px4_simulink_app_main(int argc,\n                                              char* argv[]); /* sbcheck:ok:extern_c needed */\n\nextern struct hrt_call\n    BaseRate_HRT; /* Base-rate HRT-callback is used to post base-rate semaphore */\nextern int terminatingmodel;\nextern int baserate_sem_copy; /* used for checking HRT semaphore water-mark*/\nstatic bool g_baseRateLife =\n    false;                        /* global storage to contain the status of the px4_simulink_app */\nstatic int px4_simulink_app_task; /* Handle of daemon thread */\nchar mavlink_shell_started = 0;\n\n#ifndef MW_PX4_DISABLE_MAVLINK\nconst char* mavlink_start_command[] = {\"mavlink\",      \"start\", \"-r\",     \"800000\", \"-d\",\n                                       \"/dev/ttyACM0\", \"-m\",    \"config\", \"-x\",     0};\n#endif\n\n/* Print the correct usage. */\nvoid px4_app_usage(const char* reason) {\n    if (reason) {\n        PX4_INFO(\"px4_simulink_app : %s\\n\", reason);\n    }\n    errx(1, \"usage: px4_simulink_app {start|stop|status} [-p <additional params>]\\n\\n\");\n}\n\n#if defined(MW_PX4_DISABLE_MAVLINK)\nuint8_t buffer[100];\nMavlinkShell shell;\nvoid shellWait(MavlinkShell* shell_ptr, uint8_t buf[]) {\n    /*The shell wait here is to be used for commands which are expected to\n      return a few characters (a max. of 100 characters.)*/\n    int read = 0, readTotal = 0;\n    for (int i = 0; i < 100; i++) {\n        buf[i] = 0;\n    }\n    while (strstr((char*)buf, \"nsh>\") == NULL) {\n        read = shell_ptr->read(buf + readTotal, 100 - readTotal);\n        readTotal = readTotal + read;\n    }\n}\n#endif\n\nvoid px4_simulink_app_control_MAVLink() {\n    if (mavlink_shell_started == 0) {\n#ifdef MW_PX4_DISABLE_MAVLINK\n        shell.start();\n        shellWait(&shell, buffer);\n#endif\n    }\n\n#ifndef MW_PX4_DISABLE_MAVLINK\n    int narg = sizeof(mavlink_start_command) / sizeof(mavlink_start_command[0]);\n    Mavlink::start(narg - 1, (char**)mavlink_start_command);\n#endif\n\n#ifdef MW_PX4_DISABLE_MAVLINK\n    shell.write((uint8_t*)\"mavlink stop-all\\n\", sizeof(\"mavlink stop-all\\n\"));\n    usleep(100000);\n#endif\n}\n\nint px4_simulink_app_main(int argc, char* argv[]) {\n    if (argc < 2) {\n        px4_app_usage(\"missing command\");\n    }\n\n    if (!strcmp(argv[1], \"start\")) {\n        if (g_baseRateLife == false) {\n            /* Start the Simulink Tasks here */\n#if DEBUG\n            printf(\"px4_simulink_app : Starting the Simulink model\\n\");\n            fflush(stdout);\n#endif\n\n            /* Reset semaphore */\n            g_baseRateLife = true;\n            terminatingmodel =\n                0; // reset global variable. For more info on the rational behind this, please see:\n            // http://nuttx.org/doku.php?id=wiki:nxinternal:tasks-vs-processes#nuttx_flat-build_behavior\n\n            px4_simulink_app_task = px4_task_spawn_cmd(\n                \"px4_simulink_app_task\", /* Definition of px4_task_spawn_cmd :\n                                            C:\\px4\\Firmware\\src\\platforms\\nuttx\\px4_layer\\px4_nuttx_tasks.c\n                                          */\n                SCHED_DEFAULT,           /* For STM32 F4, NuttX has SCHED_DEFAULT as SCHED_RR */\n                SCHED_PRIORITY_MAX - 15, /* SCHED_PRIORITY_MAX: 255 */\n                2048, px4_simulink_app_task_main, (char* const*)NULL);\n\n        } else {\n            warnx(\"px4_simulink_app : Simulink model is already running\\n\");\n            fflush(stdout);\n        }\n#if defined(MW_PX4_NUTTX_BUILD)\n        exit(0);\n#else\n        return 0;\n#endif\n    }\n\n    if (!strcmp(argv[1], \"stop\")) {\n        if (g_baseRateLife == true) {\n#ifdef PIL\n            errorOccurred = 1;\n#else\n            rtmSetErrorStatus(MW_StringifyDefineFunction(MODEL, _M), \"Module stopped by user\");\n            g_baseRateLife = false;\n            px4_sem_post(&baserateTaskSem);\n#endif\n#if DEBUG\n            PX4_INFO(\"px4_simulink_app : Exiting the Simulink model\\n\");\n#endif\n        } else {\n            warnx(\"px4_simulink_app : No Simulink model is running\\n\");\n        }\n\n        fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n        exit(0);\n#else\n        return 0;\n#endif\n    }\n\n    if (!strcmp(argv[1], \"status\")) {\n        if (g_baseRateLife) {\n            PX4_INFO(\"px4_simulink_app : model is running\\n\");\n        } else {\n            PX4_INFO(\"px4_simulink_app : model is not started\\n\");\n        }\n        fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n        exit(0);\n#else\n        return 0;\n#endif\n    }\n\n    px4_app_usage(\"unrecognized command\");\n#if defined(MW_PX4_NUTTX_BUILD)\n    exit(1);\n#else\n    return 1;\n#endif\n}\n\nvoid MW_PX4_Terminate() {\n    hrt_cancel(&BaseRate_HRT);\n    g_baseRateLife = false; // set status of PX4 Simulink App to stop\n\n#if defined(MW_HRT_CONSTRAINT) && (1 == MW_HRT_CONSTRAINT)\n    if (baserate_sem_copy > MW_SEM_WATERMARK) {\n        PX4_INFO(\"Hard real-time constraint violated, shutting down. Updating log file. \\n\");\n        FILE* fp_taskover_run = NULL;\n        char msg_watermark[100] = {0};\n        char msg_timestamp[50] = {0};\n        struct tm* sTm;\n        time_t now = time(NULL);\n        sTm = gmtime(&now);\n        sprintf(msg_watermark,\n                \"Base-rate semaphore exceeded water-mark value %d. Model base-rate = %.3f sec.\",\n                MW_SEM_WATERMARK, (float)MW_BASERATE_PERIOD);\n        strftime(msg_timestamp, sizeof(msg_timestamp), \"%Y-%m-%d %H:%M:%S\", sTm);\n        fp_taskover_run = fopen(\"/fs/microsd/log/task_overrun_log.txt\", \"a+\");\n        fprintf(fp_taskover_run, \"%s Timestamp=%s \\n\", msg_watermark, msg_timestamp);\n        fclose(fp_taskover_run);\n    }\n#endif\n\n#if DEBUG\n    PX4_INFO(\"px4_simulink_app : Received command to end the Simulink task \\n\");\n    fflush(stdout);\n#endif\n}\n\n// LocalWords:  HRT px nsh mavlink nuttx doku nxinternal Nutt SCHED fs microsd\n// LocalWords:  dev ACM tty\n"},{"name":"MW_custom_RTOS_header.h","type":"header","group":"other","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _MW_CUSTOM_RTOS_HEADER_H_\r\n#define _MW_CUSTOM_RTOS_HEADER_H_\r\n#define MW_BASERATE_PRIORITY           100\r\n#define MW_BASERATE_PERIOD             0.001\r\n#define MW_NUMBER_SUBRATES             0\r\n#define MW_NUMBER_APERIODIC_TASKS      0\r\n#define MW_IS_CONCURRENT               0\r\n#define MW_NUMBER_TIMER_DRIVEN_TASKS   0\r\n\r\nextern void exitFcn(int sig);\r\nextern void *terminateTask(void *arg);\r\nextern void *baseRateTask(void *arg);\r\nextern void *subrateTask(void *arg);\r\nextern pthread_t schedulerThread;\r\nextern pthread_t baseRateThread;\r\nextern pthread_t subRateThread[];\r\nextern px4_sem_t stopSem;\r\nextern px4_sem_t baserateTaskSem;\r\nextern px4_sem_t subrateTaskSem[];\r\nextern int taskId[];\r\nextern int subratePriority[];\r\n\r\n#endif\r\n\r\n#define MW_MAX_TASKNAME                16\r\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"MW_PX4_TaskControl.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE PX4 Pixhawk 6x\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERSIZE 1024\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_MAXCONTIGSAMPLES 10\n#define MW_CONNECTIONINFO_XCPONSERIAL_BAUDRATE codertarget.pixhawk.internal.getExternalModeBaudrate(hCS);\n#define MW_CONNECTIONINFO_XCPONSERIAL_COMPORT codertarget.pixhawk.internal.getExternalSerialPortName(hCS);\n#define MW_CONNECTIONINFO_XCPONSERIAL_VERBOSE 1\n#define MW_EXTMODE_CONFIGURATION XCP on Serial\n#define MW_RTOS NuttX\n#define MW_RTOSBASERATETASKPRIORITY 100\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 1\n#define MW_CMAKECONFIG px4_fmu-v6x_fixedwing\n#define MW_CHANGECMAKECONFIG 48\n#define MW_AUTOMATIC_SERIAL_SCAN 1\n#define MW_COM_UPLOAD_STORAGE \n#define MW_NUTTX_SERIAL_PORT \n#define MW_ENABLE_HITL 0\n#define MW_SIMULATOR 0\n#define MW_CONNECTEDIOSERIALPORT /dev/ttyACM0\n#define MW_CONNECTEDIOSERIALPORT_CHECKBOX 1\n#define MW_CONNECTEDIOHOSTCOMPORT \n#define MW_SIMULINKIO_MODELTRANSPORTDATAFCN px4.internal.ConnectedIO.getConfigsetInfo\n#define MW_SIMULINKIO_SERVERDEPLOYFCN px4.internal.ConnectedIO.buildAndDeployPX4IOServer\n#define MW_CLOCKING_CPUCLOCKRATEMHZ 480\n#define MW_EXTSERIALPORT 0\n#define MW_EXTMODESERIALPORT_CHECKBOX 1\n#define MW_EXTMODEHOSTCOMPORT \n#define MW_PILSERIALPORT /dev/ttyACM0\n#define MW_PILSERIALPORT_CHECKBOX 1\n#define MW_PILHOSTCOMPORT COM6\n#define MW_I2C_BUS1SPEEDKHZ_INDEX 0\n#define MW_I2C_BUS2SPEEDKHZ_INDEX 0\n#define MW_I2C_BUS3SPEEDKHZ_INDEX 0\n#define MW_I2C_BUS1SPEEDKHZ 100\n#define MW_I2C_BUS2SPEEDKHZ 100\n#define MW_I2C_BUS3SPEEDKHZ 100\n#define MW_ENABLEMAVLINKCHECKBOX 1\n#define MW_TTYACM0_BAUDRATE 27\n#define MW_TTYACM0_PARITY 0\n#define MW_TTYACM0_STOPBIT 0\n#define MW_TTYACM0_PORTMAP 48\n#define MW_TTYS0_BAUDRATE 27\n#define MW_TTYS0_PARITY 0\n#define MW_TTYS0_STOPBIT 0\n#define MW_TTYS0_PORTMAP 48\n#define MW_TTYS1_BAUDRATE 27\n#define MW_TTYS1_PARITY 0\n#define MW_TTYS1_STOPBIT 0\n#define MW_TTYS1_PORTMAP 48\n#define MW_TTYS1HWFLOWCONTROL_CHECKBOX 0\n#define MW_TTYS2_BAUDRATE 27\n#define MW_TTYS2_PARITY 0\n#define MW_TTYS2_STOPBIT 0\n#define MW_TTYS2_PORTMAP 48\n#define MW_TTYS2HWFLOWCONTROL_CHECKBOX 0\n#define MW_TTYS3_BAUDRATE 27\n#define MW_TTYS3_PARITY 0\n#define MW_TTYS3_STOPBIT 0\n#define MW_TTYS3_PORTMAP 48\n#define MW_TTYS3HWFLOWCONTROL_CHECKBOX 0\n#define MW_TTYS4_BAUDRATE 27\n#define MW_TTYS4_PARITY 0\n#define MW_TTYS4_STOPBIT 0\n#define MW_TTYS4_PORTMAP 48\n#define MW_TTYS5_BAUDRATE 27\n#define MW_TTYS5_PARITY 0\n#define MW_TTYS5_STOPBIT 0\n#define MW_TTYS5_PORTMAP 48\n#define MW_TTYS6_BAUDRATE 27\n#define MW_TTYS6_PARITY 0\n#define MW_TTYS6_STOPBIT 0\n#define MW_TTYS6_PORTMAP 48\n#define MW_TTYS7_BAUDRATE 27\n#define MW_TTYS7_PARITY 0\n#define MW_TTYS7_STOPBIT 0\n#define MW_TTYS7_PORTMAP 48\n#define MW_PWM_MAIN_ONESHOT 0\n#define MW_PWM_MAIN_FREQUENCY 50\n#define MW_PWM_AUX_ONESHOT 0\n#define MW_PWM_AUX_FREQUENCY 50\n#define MW_PWM_CH1_FAILSAFE 900\n#define MW_PWM_CH1_DISARMED 900\n#define MW_PWM_CH2_FAILSAFE 575\n#define MW_PWM_CH2_DISARMED 575\n#define MW_PWM_CH3_FAILSAFE 575\n#define MW_PWM_CH3_DISARMED 575\n#define MW_PWM_CH4_FAILSAFE 900\n#define MW_PWM_CH4_DISARMED 900\n#define MW_PWM_CH5_FAILSAFE 900\n#define MW_PWM_CH5_DISARMED 900\n#define MW_PWM_CH6_FAILSAFE 900\n#define MW_PWM_CH6_DISARMED 900\n#define MW_PWM_CH7_FAILSAFE 900\n#define MW_PWM_CH7_DISARMED 900\n#define MW_PWM_CH8_FAILSAFE 900\n#define MW_PWM_CH8_DISARMED 900\n#define MW_PWM_AUX_CH1_FAILSAFE 900\n#define MW_PWM_AUX_CH1_DISARMED 900\n#define MW_PWM_AUX_CH2_FAILSAFE 900\n#define MW_PWM_AUX_CH2_DISARMED 900\n#define MW_PWM_AUX_CH3_FAILSAFE 900\n#define MW_PWM_AUX_CH3_DISARMED 900\n#define MW_PWM_AUX_CH4_FAILSAFE 900\n#define MW_PWM_AUX_CH4_DISARMED 900\n#define MW_PWM_AUX_CH5_FAILSAFE 900\n#define MW_PWM_AUX_CH5_DISARMED 900\n#define MW_PWM_AUX_CH6_FAILSAFE 900\n#define MW_PWM_AUX_CH6_DISARMED 900\n#define MW_PWM_AUX_CH7_FAILSAFE 900\n#define MW_PWM_AUX_CH7_DISARMED 900\n#define MW_PWM_AUX_CH8_FAILSAFE 900\n#define MW_PWM_AUX_CH8_DISARMED 900\n#define MW_HRT_CONSTRAINT 0\n#define MW_SEM_WATERMARK 20\n#define MW_IOBLOCKSMODE deployed\n#define MW_DATAVERSION 2016.02\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"MW_uORB_Read.cpp","type":"source","group":"legacy","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\px4\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018-2020 The MathWorks, Inc. */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n#include \"MW_uORB_Read.h\"\n\n#define DEBUG 0\n\nvoid uORB_read_initialize(orb_metadata_t* orbData, pollfd_t* eventStructObj) {\n    int fd = orb_subscribe(orbData);\n    eventStructObj->fd = fd;\n    eventStructObj->events = POLLIN;\n#if DEBUG\n    PX4_INFO(\"* Subscribed to topic: %s (fd = %d)*\\n\", orbData->o_name, fd);\n#endif\n}\n\nboolean_T uORB_read_step(orb_metadata_t* orbData,\n                         pollfd_t* eventStructObj,\n                         void* busData,\n                         boolean_T blockingMode,\n                         double blockingTimeout) {\n    boolean_T updated = 0;\n    bool isUpdated = false;\n    if (blockingMode) {\n#if defined(MW_PX4_NUTTX_BUILD)\n        int poll_ret = px4_poll(eventStructObj, 1, blockingTimeout);\n        static int error_counter = 0;\n        if (poll_ret == 0) {\n#if DEBUG\n            PX4_ERR(\"Got no data within %.9lf second\", blockingTimeout / 1000.0);\n#endif\n        } else if (poll_ret < 0) {\n            if (error_counter < 10 || error_counter % 500 == 0) {\n                /* use a counter to prevent flooding and slowing the system down */\n#if DEBUG\n                PX4_ERR(\"ERROR return value from poll(): %d\", poll_ret);\n#endif\n            }\n            error_counter++;\n\n        } else {\n            if (eventStructObj->revents & POLLIN) {\n                orb_copy(orbData, eventStructObj->fd, busData);\n                updated = 1;\n            }\n        }\n#elif defined(MW_PX4_POSIX_BUILD)\n        double count = 0;\n        /* The blocking timeout mentioned in the block mask is seconds but\n         * system object converts it to milliseconds*/\n        while (count < blockingTimeout) {\n            // Sleep for 1 ms and then again check if\n            // uORB topic is updated\n            usleep(1000);\n            orb_check(eventStructObj->fd, &isUpdated);\n            if (isUpdated) {\n                orb_copy(orbData, eventStructObj->fd, busData);\n                break;\n            }\n            count++;\n        }\n\n        updated = isUpdated ? 1 : 0;\n#endif\n    } else {\n        orb_check(eventStructObj->fd, &isUpdated);\n        if (isUpdated) {\n            orb_copy(orbData, eventStructObj->fd, busData);\n        }\n        updated = isUpdated ? 1 : 0;\n    }\n\n    return updated;\n}\n\nvoid uORB_read_terminate(const pollfd_t* eventStructObj) {\n    orb_unsubscribe(eventStructObj->fd);\n}\n"},{"name":"MW_uORB_Write.cpp","type":"source","group":"legacy","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\px4\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018 The MathWorks, Inc. */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n#include \"MW_uORB_Write.h\"\n\n#define DEBUG 0\n\nvoid uORB_write_initialize(orb_metadata_t* orbData,\n                          orb_advert_t* orbAdvertObj,\n                          void* busData,\n                          int queueLen) {\n    *orbAdvertObj = orb_advertise_queue(orbData, busData, queueLen);    \n#if DEBUG\n    PX4_INFO(\"Started advertising topic: %s \\n\",  orbData->o_name);\n#endif    \n}\n\nvoid uORB_write_step(orb_metadata_t* orbData,\n                    orb_advert_t* orbAdvertObj,\n                    void* busData) {\n    orb_publish(orbData, *orbAdvertObj, busData);\n}\n\nvoid uORB_write_terminate(const orb_advert_t* orbAdvertObj) {\n    orb_unadvertise(*orbAdvertObj);\n}\n"},{"name":"MW_uORB_busstruct_conversion.h","type":"header","group":"other","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _MW_UORB_BUSSTRUCT_CONVERSION_H_\r\n#define _MW_UORB_BUSSTRUCT_CONVERSION_H_\r\n\r\n#include <uORB/topics/actuator_outputs_commanded.h>\r\n#include <uORB/topics/airspeed.h>\r\n#include <uORB/topics/input_rc.h>\r\n#include <uORB/topics/vehicle_angular_velocity.h>\r\n#include <uORB/topics/vehicle_attitude.h>\r\n#include <uORB/topics/vehicle_local_position.h>\r\n\r\ntypedef struct actuator_outputs_commanded_s  px4_Bus_actuator_outputs_commanded ;\r\ntypedef struct airspeed_s  px4_Bus_airspeed ;\r\ntypedef struct input_rc_s  px4_Bus_input_rc ;\r\ntypedef struct vehicle_angular_velocity_s  px4_Bus_vehicle_angular_velocity ;\r\ntypedef struct vehicle_attitude_s  px4_Bus_vehicle_attitude ;\r\ntypedef struct vehicle_local_position_s  px4_Bus_vehicle_local_position ;\r\n\r\n#endif\r\n"},{"name":"nuttxinitialize.cpp","type":"source","group":"legacy","path":"C:\\Users\\BiLab\\Documents\\StopRotorXML\\export_10112023\\buildover_fullstatemachine_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\px4\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2018-2022 The MathWorks, Inc.\n *\n * File: nuttxinitialize.c\n *\n * Abstract:\n *  This file contains RTOS thread creation functions\n *\n */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n\n/***********************************************\n * Added for Simulink Threads\n ************************************************/\npthread_attr_t attr;\nstatic baseRateInfo_t g_info;\nstruct sched_param g_sp;\n// extern volatile boolean_T runModel ;\n\n/***********************************************\n * Added for HRT\n ************************************************/\nstruct hrt_call BaseRate_HRT;\nint baserate_sem_copy;\n\n\n#define MW_RTOS_DEBUG 0\n\nbaseRateInfo_t EXT_sig_info;\nbaseRateInfo_t SDCard_sig_info;\nextern pthread_t backgroundThread;\nextern pthread_t loggingThread;\nextern void exitFcn(int sig);\n\nvoid setTaskPeriod(double periodInSeconds, int sigNo) {\n    timer_t timerId;\n    struct sigevent sev;\n    struct itimerspec its;\n    long stNanoSec;\n    int status;\n\n    /* Create a timer */\n    sev.sigev_notify = SIGEV_SIGNAL;\n    sev.sigev_signo = sigNo;\n    sev.sigev_value.sival_ptr = &timerId;\n    status = timer_create(CLOCK_REALTIME, &sev, &timerId);\n    CHECK_STATUS(status, 0, \"timer_create\");\n\n    /* Arm real-time scheduling timer */\n    stNanoSec = (long)(periodInSeconds * 1e9);\n    its.it_value.tv_sec = stNanoSec / 1000000000;\n    its.it_value.tv_nsec = stNanoSec % 1000000000;\n    its.it_interval.tv_sec = its.it_value.tv_sec;\n    its.it_interval.tv_nsec = its.it_value.tv_nsec;\n    status = timer_settime(timerId, 0, &its, NULL);\n    CHECK_STATUS(status, 0, \"timer_settime\");\n}\n\nvoid print_sem_value() {\n    PX4_WARN(\"Sem value = %d\", baserate_sem_copy);\n}\n\nstatic void Base_HRT_Callback(void* arg) {\n#ifndef PX4_CONNECTEDIO\n    int sem_value_check;\n\n    px4_sem_getvalue(&baserateTaskSem, &sem_value_check);\n    px4_sem_post(&baserateTaskSem);\n    baserate_sem_copy = sem_value_check;\n\n#endif\n}\n\n/* ---------------------------- */\n/* Externally visible functions */\n/* ---------------------------- */\nvoid myWaitForThisEvent(int sigNo) {\n    sigset_t sigMask;\n\n    sigemptyset(&sigMask);\n    sigaddset(&sigMask, sigNo);\n    sigwaitinfo(&sigMask, NULL);\n    //\tCHECK_STATUS_NOT(status, -1, \"sigwaitinfo\");\n}\n\nvoid MW_PX4_WaitForThisEvent(void* arg) {\n#ifdef EXT_MODE\n    /*pace External mode thread at 10 Hz*/\n    usleep(100000);\n\n    /*Signaling is causing issue when sample time is greater than 0.1\n     and model runs for more than 60 seconds. In this case model stop is not\n     stopping External mode. Using usleep for now to sleep the External Mode thread.*/\n\n    // baseRateInfo_t ext_info = *((baseRateInfo_t *)arg);\n    // static boolean_T isTaskPeriodSet = false;\n    // boolean_T rtmStopReq = rtmGetStopRequested(MW_StringifyDefineFunction(MODEL, _M));\n\n    // if (!isTaskPeriodSet) {\n    //     setTaskPeriod(ext_info.period, ext_info.sigNo);\n    //     isTaskPeriodSet = true;\n    // }\n\n    // if (!rtmStopReq) {\n    //     myWaitForThisEvent(ext_info.sigNo);\n    // }\n\n#endif\n}\n\nvoid myAddBlockForThisEvent(int sigNo) {\n    int status;\n    sigset_t sigMask;\n\n    sigemptyset(&sigMask);\n    sigaddset(&sigMask, sigNo);\n    status = pthread_sigmask(SIG_BLOCK, &sigMask, NULL);\n    CHECK_STATUS(status, 0, \"pthread_sigmask\");\n}\n\nvoid nuttxRTOSInit(double baseRatePeriod, int numSubrates) {\n    /* This is because in Daren's original Task callback ,a sleep was added before creating the\n     * threads*/\n    sleep(1);\n\n    int status;\n\n#if defined(MW_PX4_NUTTX_BUILD)\n    size_t stackSize;\n    int baseRatePriority = MW_BASERATE_PRIORITY;\n#endif\n\n#ifdef MW_HAS_MULTIPLE_RATES\n    int i;\n    // char taskName[20];\n#endif\n#if defined(MW_PX4_NUTTX_BUILD)\n    sched_lock();\n#endif\n    // status = px4_sem_init(&termSem, 0, 0); PX4 PSP Dev: termSem no longer needed\n    // CHECK_STATUS(status, 0,\"px4_sem_init:termSem\");\n    status = px4_sem_init(&stopSem, 0, 0);\n    CHECK_STATUS(status, 0, \"px4_sem_init:stopSem\");\n    status = px4_sem_init(&baserateTaskSem, 0, 0);\n    CHECK_STATUS(status, 0, \"px4_sem_init:baserateTaskSem\");\n\n    // or you can use/check: _POSIX_PRIORITY_SCHEDULING\n    // _POSIX_THREAD_PRIORITY_SCHEDULING\n#if !defined(_POSIX_PRIORITY_SCHEDULING)\n    PX4_INFO(\"Priority scheduling is NOT supported by your system.\");\n    PX4_INFO(\"The generated code will not run correctly because your\");\n    PX4_INFO(\"model contains multiple rates and uses multi-tasking\");\n    PX4_INFO(\"code generation mode. You can only run the generated code\");\n    PX4_INFO(\"in single-tasking mode in your system. Open\");\n    PX4_INFO(\"Simulation -> Configuration Parameters -> Solver dialog\");\n    PX4_INFO(\"and set \\\"Tasking mode for periodic sample times\\\" parameter to SingleTasking.\");\n    PX4_INFO(\n        \"Re-build the Simulink model with the new settings and try executing the generated code \"\n        \"again.\");\n    fflush(stdout);\n    exit(-1);\n#endif\n\n#if defined(MW_PX4_NUTTX_BUILD)\n    /* Set scheduling policy of the main thread to SCHED_FIFO */\n    g_sp.sched_priority = sched_get_priority_max(SCHED_FIFO) - 50;\n    status = sched_setscheduler(0, SCHED_FIFO, &g_sp);\n    CHECK_STATUS(status, 0, \"sched_setscheduler\");\n\n    /*Added init attribute and scheduler policy */\n    pthread_attr_init(&attr);\n    status = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);\n    CHECK_STATUS(status, 0, \"pthread_attr_setinheritsched\");\n    status = pthread_attr_setschedpolicy(&attr, SCHED_FIFO);\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedpolicy\");\n    // status = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n    // CHECK_STATUS(status, 0, \"pthread_attr_setdetachstate\");\n\n    /* PTHREAD_STACK_MIN is the minimum stack size required to start a thread */\n    stackSize = 8192 + PTHREAD_STACK_MIN;\n\n    /*added stack attribute back in */\n    status = pthread_attr_setstacksize(&attr, stackSize);\n    CHECK_STATUS(status, 0, \"pthread_attr_setstacksize\");\n#endif\n    /* set up info structure */\n    g_info.period = baseRatePeriod;\n    g_info.sigNo = BASERATE_TIMER_SIGNAL; // SIGRTMIN;\n\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"   stackSize = %d sched_priority = %d\", stackSize, g_sp.sched_priority);\n    PX4_INFO(\"   MW_BASERATE_PERIOD = %8.5f MW_BASERATE_PRIORITY = %d SIGRTMIN = 0x%08X\",\n             (double)baseRatePeriod, (int)baseRatePriority, SIGRTMIN);\n    PX4_INFO(\"   Init info.period = %8.5f sigNo = 0x%04X\", g_info.period, g_info.sigNo);\n    PX4_INFO(\"**creating the Base Rate thread before calling pthread_create**\");\n    fflush(stdout);\n#endif\n\n    /* Create the Base Rate Task here */\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = baseRatePriority;\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n    status = pthread_create(&baseRateThread, &attr, &baseRateTask, (void*)&g_info);\n#elif defined(MW_PX4_POSIX_BUILD)\n    status = pthread_create(&baseRateThread, nullptr, &baseRateTask, (void*)&g_info);\n#endif\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"** Base Rate Task ID = %d with Priority = %d\\n\", baseRateThread, g_sp.sched_priority);\n    fflush(stdout);\n#endif\n\n/* Create sub-rate Tasks here */\n#ifdef MW_HAS_MULTIPLE_RATES\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"Creating sub-rate task threads\\n\");\n    PX4_INFO(\"Number of sub rate tasks: %d \\n\", MW_NUMBER_SUBRATES);\n    fflush(stdout);\n#endif\n\n    for (i = 0; i < MW_NUMBER_SUBRATES; i++) {\n        taskId[i] = i;\n        status = px4_sem_init(&subrateTaskSem[i], 0, 0);\n        CHECK_STATUS(status, 0, \"px4_sem_init: subrateTaskSem\");\n        // g_sp.sched_priority = MW_BASERATE_PRIORITY -40 + subratePriority[i] - 1;\n        g_sp.sched_priority = subratePriority[i];\n#if MW_RTOS_DEBUG\n        PX4_INFO(\"MW_SUBRATE_PRIORITY = %d \", (int)g_sp.sched_priority);\n#endif\n\n#if defined(MW_PX4_NUTTX_BUILD)\n        status = pthread_attr_setschedparam(&attr, &g_sp);\n        CHECK_STATUS(status, 0, \"pthread_attr_setschedparam\");\n        status = pthread_create(&subRateThread[i], &attr, &subrateTask, (void*)&taskId[i]);\n#elif defined(MW_PX4_POSIX_BUILD)\n        status = pthread_create(&subRateThread[i], nullptr, &subrateTask, (void*)&taskId[i]);\n#endif\n        CHECK_STATUS(status, 0, \"pthread_create\");\n\n#if MW_RTOS_DEBUG\n        PX4_INFO(\"** Sub Rate Task ID = %d \", subRateThread[i]);\n        fflush(stdout);\n#endif\n    }\n#endif // End of \"If Multiple Rates\" check\n\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = baseRatePriority;\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n#endif\n\n    /* Create the Scheduler Task here */\n    long stMicroSec;\n    stMicroSec = (long)(g_info.period * 1e6);\n    hrt_call_every(&BaseRate_HRT, stMicroSec, stMicroSec, Base_HRT_Callback,\n                   NULL); // timing callback to post base-rate semaphore\n\n/* Create the External Mode Task here */\n#ifdef EXT_MODE\n    /*---------- Creating EXT-mode Background Task ------------------*/\n    /* Setup signal info to block for EXT Mode */\n    EXT_sig_info.period = 0.1; // Sample rate at which we want Simulink to update w/ ext mode\n    EXT_sig_info.sigNo = SIGRTMIN;\n    /* Signaling the thread not working for low sample frequency*/\n    // sigemptyset(&EXT_sig_info.sigMask);\n    // sigaddset(&EXT_sig_info.sigMask, EXT_sig_info.sigNo);\n    // myAddBlockForThisEvent(EXT_sig_info.sigNo);\n\n    /* Setup thread for Custom Task */\n    fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = 40; // default is 100\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n    status = pthread_create(&backgroundThread, &attr, &backgroundTask, (void*)&EXT_sig_info);\n#elif defined(MW_PX4_POSIX_BUILD)\n    status = pthread_create(&backgroundThread, nullptr, &backgroundTask, (void*)&EXT_sig_info);\n#endif\n    CHECK_STATUS(status, 0, \"EXT Mode Background pthread_create\");\n/*---------------------------------------------------------*/\n#endif\n\n/* Create the SD Card Task here */\n#if MAT_FILE\n    /*---------- Creating SD Card Background Task ------------------*/\n    fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = 40; // default is 100\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n    status = pthread_create(&loggingThread, &attr, &loggingThreadFcn, NULL);\n#elif defined(MW_PX4_POSIX_BUILD)\n    status = pthread_create(&loggingThread, nullptr, &loggingThreadFcn, NULL);\n#endif\n    CHECK_STATUS(status, 0, \"SD Card Background pthread_create\");\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"** SD Card Background ID = %d \", loggingThread);\n    fflush(stdout);\n#endif\n\n/*---------------------------------------------------------*/\n#endif\n\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"px4_simulink_app : Created Simulink task threads successfully\\n\");\n    fflush(stdout);\n#endif\n#if defined(MW_PX4_NUTTX_BUILD)\n    sched_unlock();\n#endif\n}\n\n/*---------- Following function is added as a workaround for uavcan module build failure -------------\n  Original definition of the function is in the file <px4dir>\\Firmware\\Boards\\px4\\fmu-v5\\src\\can.c*/\n#if defined(MW_PX4_NUTTX_BUILD) && defined(CONFIG_CAN) && defined(UAVCAN_NUM_IFACES_RUNTIME)\n__EXPORT\nuint16_t board_get_can_interfaces(void)\n{\n\tuint16_t enabled_interfaces = 0x7;\n\n\tif (!PX4_MFT_HW_SUPPORTED(PX4_MFT_CAN2)) {\n\t\tenabled_interfaces &= ~(1 << 1);\n\t}\n\n\tif (!PX4_MFT_HW_SUPPORTED(PX4_MFT_CAN3)) {\n\t\tenabled_interfaces &= ~(1 << 2);\n\t}\n\n\treturn enabled_interfaces;\n }\n#endif\n/*---------------------------------------------------------*/\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};